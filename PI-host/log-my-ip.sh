#!/usr/bin/env bash
########################################################################################################
# Author            : "Robert McKenzie" <rmckenzi@rpmdp.com>
# Script Name       : log-my-ip.sh
# Description       : This script is written to send me a message on Telegram at the time of a
#					: reboot which includes the hostname, internal and external IP's and a reason
#					: for the reboot if one is provided.  It also sends commands to a linux server
#					: online where I collect the same info into a csv file, not sure what I'll do
#					: with this going forward but it's there, being captured, just incase.
#
# Date              : 16/07/2019
#
# Worth while notes :
# https://kvz.io/blog/2013/11/21/bash-best-practices/
#
########################################################################################################
#set -x
# Force script to exit on any error
#set -o errexit
# Prevents pipe errors and false true responses.
#set -o pipefail
#
########################################################################################################
# Setting up for some colours, use the ${_RESTORE} after a colour to return to normal
# black and white kinda thing.

_RESTORE='\033[0m'
_BOLD=''
_RED='\033[00;31m'
_GREEN='\033[00;32m'
_YELLOW='\033[00;33m'
_BLUE='\033[00;34m'
_PURPLE='\033[00;35m'
_WHITE='\033[01;37m'

# Disable colors and tput in non-interactive environments (e.g., cron)
if [ -n "${TERM:-}" ] && [ "$TERM" != "dumb" ] && [ -t 1 ] && command -v tput >/dev/null 2>&1; then
	_BOLD=$(tput bold 2>/dev/null || printf '')
else
    _RESTORE=''
    _RED=''
    _GREEN=''
    _YELLOW=''
    _BLUE=''
    _PURPLE=''
    _WHITE=''
fi
if [ -f /usr/local/etc/log-my-ip.ini ]; then
	source /usr/local/etc/log-my-ip.ini
else

	# This the branch used to check for updates
	GIT_BRANCH="main"

	# If you want to use the self updating function, change the from NO to YES
	USE_SELFUPATE=NO

	# Telegram (TG) settings.. Token is your private bot key when it was created.  Don't give this out
	TGTOKEN="TELEGRAM TOKEN"				# This is your super secret bot token, keep it private
	TGCHATID="TELEGRAM CHAT ID"				# Send only as the user in a private message
	TGGRPID="TELEGRAM GROUP ID"				# Send to private group "Messages From My Bots"

	# Link to my server that you collect the data
	_MYSERVER="server.acme.com"				# This is the FQDN (leave blank to disable this function)
	# Path on the webserver to the php script
	_SECRETPATH="1234abcdQWERTY"				# This is added to the URL if you want to obfiscate the URL

	# My network range - This is used when searching to make sure we have an IP assigned, it might change later
	# to another method but for now it's what I'm using.  So enter something we can search for like:  172.16.29
	# or 192.168.0, etc
	_my_network_range="192.168.0"

fi

TGURL="https://api.telegram.org/bot${TGTOKEN}/sendMessage"		# This shouldn't really change

# Link to my server that you collect the data
GCURL="http://${_MYSERVER}/<PATH TO YOUR PHP SCRIPT>"

WGETOPTS=" -q --no-check-certificate -O /dev/null"

# Shouldn't need to touch these
hostname="$(hostname)"

intip=""
# Avoid infinite loop waiting for a specific LAN range when running outside home network.
# Behavior:
# - If _my_network_range is empty or "ANY", accept any non-empty IP and continue.
# - Otherwise, wait up to NETWORK_WAIT_MAX_ATTEMPTS (default 24) for a matching IP; then continue with whatever IP is available.
attempt=0
max_attempts=${NETWORK_WAIT_MAX_ATTEMPTS:-24} # 24 * 5s = 2 minutes
require_match=1
if [ -z "${_my_network_range:-}" ] || [ "${_my_network_range^^}" = "ANY" ]; then
	require_match=0
fi
while :; do
	intip="$(hostname -I | awk '{print $1}')"
	if [ -n "$intip" ]; then
		if [ $require_match -eq 0 ] || echo "$intip" | grep -q "${_my_network_range}"; then
			break
		fi
	fi
	attempt=$((attempt+1))
	if [ $attempt -ge $max_attempts ]; then
		# Timed out waiting for a match; continue with the current IP (may be public) or empty if none.
		break
	fi
	sleep 5
done

mydate="$(date)"

########################################################################################################
# The script starts here - Functions first
########################################################################################################

# Enable self-update by editing /usr/local/etc/log-my-ip.ini
enable_self_update_ini()
{
	local ini="/usr/local/etc/log-my-ip.ini"
	# Require root to write the INI
	if [ "$(id -u)" != "0" ]; then
		echo -e "${_RED}Must be root to modify ${ini}${_RESTORE}"
		return 1
	fi
	# Create file if missing with minimal content
	if [ ! -f "$ini" ]; then
		mkdir -p /usr/local/etc
		{
			echo "# Auto-generated by log-my-ip.sh --enable-self-update"
			echo "USE_SELFUPATE=YES"
			echo "GIT_BRANCH=\"main\""
		} > "$ini"
	else
		# Update or append USE_SELFUPATE
		if grep -q '^USE_SELFUPATE=' "$ini"; then
			sed -i 's/^USE_SELFUPATE=.*/USE_SELFUPATE=YES/' "$ini"
		else
			echo "USE_SELFUPATE=YES" >> "$ini"
		fi
		# Update or append GIT_BRANCH
		if grep -q '^GIT_BRANCH=' "$ini"; then
			sed -i 's/^GIT_BRANCH=.*/GIT_BRANCH="main"/' "$ini"
		else
			echo 'GIT_BRANCH="main"' >> "$ini"
		fi
	fi
	echo -e "${_GREEN}Enabled self-update in ${ini}${_RESTORE}"
}

# Test for dnsutils - we need the dig command
check_for_deps()
{
	which dig &> /dev/null
	_HAVE_DIG=$?
	which lsb_release &> /dev/null
	_HAVE_LSB=$?
	which curl &> /dev/null
	_HAVE_CURL=$?

	if [ ${_HAVE_DIG} = 1 ] || [ ${_HAVE_LSB} = 1 ] || [ ${_HAVE_CURL} = 1 ]; then
		echo -e "${_RED}Oh SNAP! Looks like you're missing some dependencies.${_RESTORE}"
		if [ ${_HAVE_DIG} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}dig${_RESTORE} command. Please install ${_GREEN}dnsutils${_RESTORE} on DEB systems,"
			echo -e "and ${_GREEN}bind-utils${_RESTORE} on RPM systems."
			echo
		fi
		if [ ${_HAVE_LSB} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}lsb_release${_RESTORE} command. Please install ${_GREEN}redhat-lsb-core${_RESTORE} in CentOS and RHEL."
			echo
		fi
		if [ ${_HAVE_CURL} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}curl${_RESTORE} command. Please install ${_GREEN}curl${_RESTORE}."
			echo
		fi
		exit 1
	fi
}

# Resolve external/public IPv4 address using multiple strategies (DNS + HTTPS fallbacks)
get_external_ip()
{
	local cand=""
	# Try DNS methods first, if dig is available
	if command -v dig >/dev/null 2>&1; then
		cand="$(dig +short -4 TXT o-o.myaddr.l.google.com @ns1.google.com 2>/dev/null | tr -d '"' | head -n1)"
		if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
			cand="$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null | head -n1)"
		fi
	fi

	# If DNS didn't work, try HTTPS-based services with curl
	if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		for url in \
			https://api.ipify.org \
			https://ifconfig.me/ip \
			https://icanhazip.com \
			https://checkip.amazonaws.com \
			https://ipinfo.io/ip
		do
			cand="$(curl -4 -fsS --max-time 3 --connect-timeout 2 "$url" 2>/dev/null | tr -d '\n\r\t ' | head -c 64)"
			if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
				break
			fi
		done
	fi

	if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		extip="$cand"
	else
		extip="Unknown"
	fi
}

send_message_to_telegram()
{
    tmpfile=$(mktemp /tmp/telebot.XXXXXXX)
    cat > $tmpfile <<EOF
{"chat_id":"$TGGRPID", "parse_mode":"markdown", "text":"*System Update*: $note\n*Date*: ${mydate}\n*Hostname*: $hostname\n*Internal IP*: $intip\n*External IP*: $extip"}
EOF
    curl -k --header 'Content-Type: application/json' \
        --data-binary @${tmpfile} \
        --request POST ${TGURL}
    rm -f $tmpfile
}

# This function will send our reboot message to a server where you have a script running to receive it.
send_message_to_server()
{
	PING=1
	while [ ${PING} -gt 0 ]
	do
		ping -c 5 ${_MYSERVER} &> /dev/null
		PING=$?
	done
	wget ${WGETOPTS} ${GCURL} --post-data="hostname=${hostname}&intip=${intip}&extip=${extip}&mydate=${mydate}&note=${note}"
	if [ "${note}" = "REBOOT" ];then
		send_message
	fi
}

self_update() {
    [ "$UPDATE_GUARD" ] && return
    export UPDATE_GUARD=YES
    command -v git >/dev/null 2>&1 || return
    if ! getent hosts github.com >/dev/null 2>&1; then
        return
    fi

	_SCRIPT=$(readlink -f "$0")
	_SCRIPTPATH=$(dirname "$_SCRIPT")
	_SCRIPTNAME="$0"

	(
		cd "$_SCRIPTPATH" || exit 0
		command -v git >/dev/null 2>&1 || exit 0
		git fetch --all --quiet || exit 0
		local _BRANCH
		_BRANCH=${GIT_BRANCH:-main}
		git show-ref --verify --quiet "refs/remotes/origin/${_BRANCH}" || exit 0
		local local_before remote_target local_after
		local_before=$(git rev-parse --verify HEAD 2>/dev/null) || exit 0
		remote_target=$(git rev-parse --verify "origin/${_BRANCH}" 2>/dev/null) || exit 0
		if [ "$local_before" != "$remote_target" ]; then
			echo "Found a new version of me, updating myself..."
			git checkout -q "${_BRANCH}" || true
			git pull --force -q || true
			local_after=$(git rev-parse --verify HEAD 2>/dev/null) || local_after="unknown"
			# Optionally send a Telegram notice about the update
			if [ -n "${TGTOKEN:-}" ] && [ -n "${TGGRPID:-}" ]; then
				__old_note="${note:-}"
				old_short=$(printf '%s' "$local_before" | cut -c1-7)
				new_short=$(printf '%s' "$local_after" | cut -c1-7)
				note="Self-update applied on ${hostname} (branch ${_BRANCH}): ${old_short} -> ${new_short}"
				send_message_to_telegram || true
				note="${__old_note}"
			fi
			echo "Running the new version..."
			exec "$_SCRIPT" "${ARGS}"
			exit 0
		fi
	)
	echo "Already the latest version."
}

########################################################################################################
# The script starts here - Functions first
########################################################################################################

# Lets make sure we have some tools we need.  If not then the script will try to install dnsutils, if it 
# fails then exit.
# Handle CLI to enable self-update and exit
RAW_ARGS=("$@")

# Detect REBOOT to skip self-update on early boot
is_reboot_run=0
for _a in "${RAW_ARGS[@]}"; do
  case "$_a" in
    --reboot|REBOOT) is_reboot_run=1; break;;
  esac
done

# Enable self-update by editing /usr/local/etc/log-my-ip.ini
enable_self_update_ini()
{
	local ini="/usr/local/etc/log-my-ip.ini"
	# Require root to write the INI
	if [ "$(id -u)" != "0" ]; then
		echo -e "${_RED}Must be root to modify ${ini}${_RESTORE}"
		return 1
	fi
	# Create file if missing with minimal content
	if [ ! -f "$ini" ]; then
		mkdir -p /usr/local/etc
		{
			echo "# Auto-generated by log-my-ip.sh --enable-self-update"
			echo "USE_SELFUPATE=YES"
			echo "GIT_BRANCH=\"main\""
		} > "$ini"
	else
		# Update or append USE_SELFUPATE
		if grep -q '^USE_SELFUPATE=' "$ini"; then
			sed -i 's/^USE_SELFUPATE=.*/USE_SELFUPATE=YES/' "$ini"
		else
			echo "USE_SELFUPATE=YES" >> "$ini"
		fi
		# Update or append GIT_BRANCH
		if grep -q '^GIT_BRANCH=' "$ini"; then
			sed -i 's/^GIT_BRANCH=.*/GIT_BRANCH="main"/' "$ini"
		else
			echo 'GIT_BRANCH="main"' >> "$ini"
		fi
	fi
	echo -e "${_GREEN}Enabled self-update in ${ini}${_RESTORE}"
}

# Test for dnsutils - we need the dig command
check_for_deps()
{
	which dig &> /dev/null
	_HAVE_DIG=$?
	which lsb_release &> /dev/null
	_HAVE_LSB=$?
	which curl &> /dev/null
	_HAVE_CURL=$?

	if [ ${_HAVE_DIG} = 1 ] || [ ${_HAVE_LSB} = 1 ] || [ ${_HAVE_CURL} = 1 ]; then
		echo -e "${_RED}Oh SNAP! Looks like you're missing some dependencies.${_RESTORE}"
		if [ ${_HAVE_DIG} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}dig${_RESTORE} command. Please install ${_GREEN}dnsutils${_RESTORE} on DEB systems,"
			echo -e "and ${_GREEN}bind-utils${_RESTORE} on RPM systems."
			echo
		fi
		if [ ${_HAVE_LSB} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}lsb_release${_RESTORE} command. Please install ${_GREEN}redhat-lsb-core${_RESTORE} in CentOS and RHEL."
			echo
		fi
		if [ ${_HAVE_CURL} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}curl${_RESTORE} command. Please install ${_GREEN}curl${_RESTORE}."
			echo
		fi
		exit 1
	fi
}

# Resolve external/public IPv4 address using multiple strategies (DNS + HTTPS fallbacks)
get_external_ip()
{
	local cand=""
	# Try DNS methods first, if dig is available
	if command -v dig >/dev/null 2>&1; then
		cand="$(dig +short -4 TXT o-o.myaddr.l.google.com @ns1.google.com 2>/dev/null | tr -d '"' | head -n1)"
		if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
			cand="$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null | head -n1)"
		fi
	fi

	# If DNS didn't work, try HTTPS-based services with curl
	if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		for url in \
			https://api.ipify.org \
			https://ifconfig.me/ip \
			https://icanhazip.com \
			https://checkip.amazonaws.com \
			https://ipinfo.io/ip
		do
			cand="$(curl -4 -fsS --max-time 3 --connect-timeout 2 "$url" 2>/dev/null | tr -d '\n\r\t ' | head -c 64)"
			if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
				break
			fi
		done
	fi

	if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		extip="$cand"
	else
		extip="Unknown"
	fi
}

send_message_to_telegram()
{
    tmpfile=$(mktemp /tmp/telebot.XXXXXXX)
    cat > $tmpfile <<EOF
{"chat_id":"$TGGRPID", "parse_mode":"markdown", "text":"*System Update*: $note\n*Date*: ${mydate}\n*Hostname*: $hostname\n*Internal IP*: $intip\n*External IP*: $extip"}
EOF
    curl -k --header 'Content-Type: application/json' \
        --data-binary @${tmpfile} \
        --request POST ${TGURL}
    rm -f $tmpfile
}

# This function will send our reboot message to a server where you have a script running to receive it.
send_message_to_server()
{
	PING=1
	while [ ${PING} -gt 0 ]
	do
		ping -c 5 ${_MYSERVER} &> /dev/null
		PING=$?
	done
	wget ${WGETOPTS} ${GCURL} --post-data="hostname=${hostname}&intip=${intip}&extip=${extip}&mydate=${mydate}&note=${note}"
	if [ "${note}" = "REBOOT" ];then
		send_message
	fi
}

self_update() {
    [ "$UPDATE_GUARD" ] && return
    export UPDATE_GUARD=YES
    command -v git >/dev/null 2>&1 || return
    if ! getent hosts github.com >/dev/null 2>&1; then
        return
    fi

	_SCRIPT=$(readlink -f "$0")
	_SCRIPTPATH=$(dirname "$_SCRIPT")
	_SCRIPTNAME="$0"

	(
		cd "$_SCRIPTPATH" || exit 0
		command -v git >/dev/null 2>&1 || exit 0
		git fetch --all --quiet || exit 0
		local _BRANCH
		_BRANCH=${GIT_BRANCH:-main}
		git show-ref --verify --quiet "refs/remotes/origin/${_BRANCH}" || exit 0
		local local_before remote_target local_after
		local_before=$(git rev-parse --verify HEAD 2>/dev/null) || exit 0
		remote_target=$(git rev-parse --verify "origin/${_BRANCH}" 2>/dev/null) || exit 0
		if [ "$local_before" != "$remote_target" ]; then
			echo "Found a new version of me, updating myself..."
			git checkout -q "${_BRANCH}" || true
			git pull --force -q || true
			local_after=$(git rev-parse --verify HEAD 2>/dev/null) || local_after="unknown"
			# Optionally send a Telegram notice about the update
			if [ -n "${TGTOKEN:-}" ] && [ -n "${TGGRPID:-}" ]; then
				__old_note="${note:-}"
				old_short=$(printf '%s' "$local_before" | cut -c1-7)
				new_short=$(printf '%s' "$local_after" | cut -c1-7)
				note="Self-update applied on ${hostname} (branch ${_BRANCH}): ${old_short} -> ${new_short}"
				send_message_to_telegram || true
				note="${__old_note}"
			fi
			echo "Running the new version..."
			exec "$_SCRIPT" "${ARGS}"
			exit 0
		fi
	)
	echo "Already the latest version."
}

########################################################################################################
# The script starts here - Functions first
########################################################################################################

# Lets make sure we have some tools we need.  If not then the script will try to install dnsutils, if it 
# fails then exit.
# Handle CLI to enable self-update and exit
RAW_ARGS=("$@")

# Detect REBOOT to skip self-update on early boot
is_reboot_run=0
for _a in "${RAW_ARGS[@]}"; do
  case "$_a" in
    --reboot|REBOOT) is_reboot_run=1; break;;
  esac
done

# Enable self-update by editing /usr/local/etc/log-my-ip.ini
enable_self_update_ini()
{
	local ini="/usr/local/etc/log-my-ip.ini"
	# Require root to write the INI
	if [ "$(id -u)" != "0" ]; then
		echo -e "${_RED}Must be root to modify ${ini}${_RESTORE}"
		return 1
	fi
	# Create file if missing with minimal content
	if [ ! -f "$ini" ]; then
		mkdir -p /usr/local/etc
		{
			echo "# Auto-generated by log-my-ip.sh --enable-self-update"
			echo "USE_SELFUPATE=YES"
			echo "GIT_BRANCH=\"main\""
		} > "$ini"
	else
		# Update or append USE_SELFUPATE
		if grep -q '^USE_SELFUPATE=' "$ini"; then
			sed -i 's/^USE_SELFUPATE=.*/USE_SELFUPATE=YES/' "$ini"
		else
			echo "USE_SELFUPATE=YES" >> "$ini"
		fi
		# Update or append GIT_BRANCH
		if grep -q '^GIT_BRANCH=' "$ini"; then
			sed -i 's/^GIT_BRANCH=.*/GIT_BRANCH="main"/' "$ini"
		else
			echo 'GIT_BRANCH="main"' >> "$ini"
		fi
	fi
	echo -e "${_GREEN}Enabled self-update in ${ini}${_RESTORE}"
}

# Test for dnsutils - we need the dig command
check_for_deps()
{
	which dig &> /dev/null
	_HAVE_DIG=$?
	which lsb_release &> /dev/null
	_HAVE_LSB=$?
	which curl &> /dev/null
	_HAVE_CURL=$?

	if [ ${_HAVE_DIG} = 1 ] || [ ${_HAVE_LSB} = 1 ] || [ ${_HAVE_CURL} = 1 ]; then
		echo -e "${_RED}Oh SNAP! Looks like you're missing some dependencies.${_RESTORE}"
		if [ ${_HAVE_DIG} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}dig${_RESTORE} command. Please install ${_GREEN}dnsutils${_RESTORE} on DEB systems,"
			echo -e "and ${_GREEN}bind-utils${_RESTORE} on RPM systems."
			echo
		fi
		if [ ${_HAVE_LSB} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}lsb_release${_RESTORE} command. Please install ${_GREEN}redhat-lsb-core${_RESTORE} in CentOS and RHEL."
			echo
		fi
		if [ ${_HAVE_CURL} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}curl${_RESTORE} command. Please install ${_GREEN}curl${_RESTORE}."
			echo
		fi
		exit 1
	fi
}

# Resolve external/public IPv4 address using multiple strategies (DNS + HTTPS fallbacks)
get_external_ip()
{
	local cand=""
	# Try DNS methods first, if dig is available
	if command -v dig >/dev/null 2>&1; then
		cand="$(dig +short -4 TXT o-o.myaddr.l.google.com @ns1.google.com 2>/dev/null | tr -d '"' | head -n1)"
		if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
			cand="$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null | head -n1)"
		fi
	fi

	# If DNS didn't work, try HTTPS-based services with curl
	if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		for url in \
			https://api.ipify.org \
			https://ifconfig.me/ip \
			https://icanhazip.com \
			https://checkip.amazonaws.com \
			https://ipinfo.io/ip
		do
			cand="$(curl -4 -fsS --max-time 3 --connect-timeout 2 "$url" 2>/dev/null | tr -d '\n\r\t ' | head -c 64)"
			if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
				break
			fi
		done
	fi

	if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		extip="$cand"
	else
		extip="Unknown"
	fi
}

send_message_to_telegram()
{
    tmpfile=$(mktemp /tmp/telebot.XXXXXXX)
    cat > $tmpfile <<EOF
{"chat_id":"$TGGRPID", "parse_mode":"markdown", "text":"*System Update*: $note\n*Date*: ${mydate}\n*Hostname*: $hostname\n*Internal IP*: $intip\n*External IP*: $extip"}
EOF
    curl -k --header 'Content-Type: application/json' \
        --data-binary @${tmpfile} \
        --request POST ${TGURL}
    rm -f $tmpfile
}

# This function will send our reboot message to a server where you have a script running to receive it.
send_message_to_server()
{
	PING=1
	while [ ${PING} -gt 0 ]
	do
		ping -c 5 ${_MYSERVER} &> /dev/null
		PING=$?
	done
	wget ${WGETOPTS} ${GCURL} --post-data="hostname=${hostname}&intip=${intip}&extip=${extip}&mydate=${mydate}&note=${note}"
	if [ "${note}" = "REBOOT" ];then
		send_message
	fi
}

self_update() {
    [ "$UPDATE_GUARD" ] && return
    export UPDATE_GUARD=YES
    command -v git >/dev/null 2>&1 || return
    if ! getent hosts github.com >/dev/null 2>&1; then
        return
    fi

	_SCRIPT=$(readlink -f "$0")
	_SCRIPTPATH=$(dirname "$_SCRIPT")
	_SCRIPTNAME="$0"

	(
		cd "$_SCRIPTPATH" || exit 0
		command -v git >/dev/null 2>&1 || exit 0
		git fetch --all --quiet || exit 0
		local _BRANCH
		_BRANCH=${GIT_BRANCH:-main}
		git show-ref --verify --quiet "refs/remotes/origin/${_BRANCH}" || exit 0
		local local_before remote_target local_after
		local_before=$(git rev-parse --verify HEAD 2>/dev/null) || exit 0
		remote_target=$(git rev-parse --verify "origin/${_BRANCH}" 2>/dev/null) || exit 0
		if [ "$local_before" != "$remote_target" ]; then
			echo "Found a new version of me, updating myself..."
			git checkout -q "${_BRANCH}" || true
			git pull --force -q || true
			local_after=$(git rev-parse --verify HEAD 2>/dev/null) || local_after="unknown"
			# Optionally send a Telegram notice about the update
			if [ -n "${TGTOKEN:-}" ] && [ -n "${TGGRPID:-}" ]; then
				__old_note="${note:-}"
				old_short=$(printf '%s' "$local_before" | cut -c1-7)
				new_short=$(printf '%s' "$local_after" | cut -c1-7)
				note="Self-update applied on ${hostname} (branch ${_BRANCH}): ${old_short} -> ${new_short}"
				send_message_to_telegram || true
				note="${__old_note}"
			fi
			echo "Running the new version..."
			exec "$_SCRIPT" "${ARGS}"
			exit 0
		fi
	)
	echo "Already the latest version."
}

########################################################################################################
# The script starts here - Functions first
########################################################################################################

# Lets make sure we have some tools we need.  If not then the script will try to install dnsutils, if it 
# fails then exit.
# Handle CLI to enable self-update and exit
RAW_ARGS=("$@")

# Detect REBOOT to skip self-update on early boot
is_reboot_run=0
for _a in "${RAW_ARGS[@]}"; do
  case "$_a" in
    --reboot|REBOOT) is_reboot_run=1; break;;
  esac
done

# Enable self-update by editing /usr/local/etc/log-my-ip.ini
enable_self_update_ini()
{
	local ini="/usr/local/etc/log-my-ip.ini"
	# Require root to write the INI
	if [ "$(id -u)" != "0" ]; then
		echo -e "${_RED}Must be root to modify ${ini}${_RESTORE}"
		return 1
	fi
	# Create file if missing with minimal content
	if [ ! -f "$ini" ]; then
		mkdir -p /usr/local/etc
		{
			echo "# Auto-generated by log-my-ip.sh --enable-self-update"
			echo "USE_SELFUPATE=YES"
			echo "GIT_BRANCH=\"main\""
		} > "$ini"
	else
		# Update or append USE_SELFUPATE
		if grep -q '^USE_SELFUPATE=' "$ini"; then
			sed -i 's/^USE_SELFUPATE=.*/USE_SELFUPATE=YES/' "$ini"
		else
			echo "USE_SELFUPATE=YES" >> "$ini"
		fi
		# Update or append GIT_BRANCH
		if grep -q '^GIT_BRANCH=' "$ini"; then
			sed -i 's/^GIT_BRANCH=.*/GIT_BRANCH="main"/' "$ini"
		else
			echo 'GIT_BRANCH="main"' >> "$ini"
		fi
	fi
	echo -e "${_GREEN}Enabled self-update in ${ini}${_RESTORE}"
}

# Test for dnsutils - we need the dig command
check_for_deps()
{
	which dig &> /dev/null
	_HAVE_DIG=$?
	which lsb_release &> /dev/null
	_HAVE_LSB=$?
	which curl &> /dev/null
	_HAVE_CURL=$?

	if [ ${_HAVE_DIG} = 1 ] || [ ${_HAVE_LSB} = 1 ] || [ ${_HAVE_CURL} = 1 ]; then
		echo -e "${_RED}Oh SNAP! Looks like you're missing some dependencies.${_RESTORE}"
		if [ ${_HAVE_DIG} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}dig${_RESTORE} command. Please install ${_GREEN}dnsutils${_RESTORE} on DEB systems,"
			echo -e "and ${_GREEN}bind-utils${_RESTORE} on RPM systems."
			echo
		fi
		if [ ${_HAVE_LSB} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}lsb_release${_RESTORE} command. Please install ${_GREEN}redhat-lsb-core${_RESTORE} in CentOS and RHEL."
			echo
		fi
		if [ ${_HAVE_CURL} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}curl${_RESTORE} command. Please install ${_GREEN}curl${_RESTORE}."
			echo
		fi
		exit 1
	fi
}

# Resolve external/public IPv4 address using multiple strategies (DNS + HTTPS fallbacks)
get_external_ip()
{
	local cand=""
	# Try DNS methods first, if dig is available
	if command -v dig >/dev/null 2>&1; then
		cand="$(dig +short -4 TXT o-o.myaddr.l.google.com @ns1.google.com 2>/dev/null | tr -d '"' | head -n1)"
		if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
			cand="$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null | head -n1)"
		fi
	fi

	# If DNS didn't work, try HTTPS-based services with curl
	if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		for url in \
			https://api.ipify.org \
			https://ifconfig.me/ip \
			https://icanhazip.com \
			https://checkip.amazonaws.com \
			https://ipinfo.io/ip
		do
			cand="$(curl -4 -fsS --max-time 3 --connect-timeout 2 "$url" 2>/dev/null | tr -d '\n\r\t ' | head -c 64)"
			if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
				break
			fi
		done
	fi

	if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		extip="$cand"
	else
		extip="Unknown"
	fi
}

send_message_to_telegram()
{
    tmpfile=$(mktemp /tmp/telebot.XXXXXXX)
    cat > $tmpfile <<EOF
{"chat_id":"$TGGRPID", "parse_mode":"markdown", "text":"*System Update*: $note\n*Date*: ${mydate}\n*Hostname*: $hostname\n*Internal IP*: $intip\n*External IP*: $extip"}
EOF
    curl -k --header 'Content-Type: application/json' \
        --data-binary @${tmpfile} \
        --request POST ${TGURL}
    rm -f $tmpfile
}

# This function will send our reboot message to a server where you have a script running to receive it.
send_message_to_server()
{
	PING=1
	while [ ${PING} -gt 0 ]
	do
		ping -c 5 ${_MYSERVER} &> /dev/null
		PING=$?
	done
	wget ${WGETOPTS} ${GCURL} --post-data="hostname=${hostname}&intip=${intip}&extip=${extip}&mydate=${mydate}&note=${note}"
	if [ "${note}" = "REBOOT" ];then
		send_message
	fi
}

self_update() {
    [ "$UPDATE_GUARD" ] && return
    export UPDATE_GUARD=YES
    command -v git >/dev/null 2>&1 || return
    if ! getent hosts github.com >/dev/null 2>&1; then
        return
    fi

	_SCRIPT=$(readlink -f "$0")
	_SCRIPTPATH=$(dirname "$_SCRIPT")
	_SCRIPTNAME="$0"

	(
		cd "$_SCRIPTPATH" || exit 0
		command -v git >/dev/null 2>&1 || exit 0
		git fetch --all --quiet || exit 0
		local _BRANCH
		_BRANCH=${GIT_BRANCH:-main}
		git show-ref --verify --quiet "refs/remotes/origin/${_BRANCH}" || exit 0
		local local_before remote_target local_after
		local_before=$(git rev-parse --verify HEAD 2>/dev/null) || exit 0
		remote_target=$(git rev-parse --verify "origin/${_BRANCH}" 2>/dev/null) || exit 0
		if [ "$local_before" != "$remote_target" ]; then
			echo "Found a new version of me, updating myself..."
			git checkout -q "${_BRANCH}" || true
			git pull --force -q || true
			local_after=$(git rev-parse --verify HEAD 2>/dev/null) || local_after="unknown"
			# Optionally send a Telegram notice about the update
			if [ -n "${TGTOKEN:-}" ] && [ -n "${TGGRPID:-}" ]; then
				__old_note="${note:-}"
				old_short=$(printf '%s' "$local_before" | cut -c1-7)
				new_short=$(printf '%s' "$local_after" | cut -c1-7)
				note="Self-update applied on ${hostname} (branch ${_BRANCH}): ${old_short} -> ${new_short}"
				send_message_to_telegram || true
				note="${__old_note}"
			fi
			echo "Running the new version..."
			exec "$_SCRIPT" "${ARGS}"
			exit 0
		fi
	)
	echo "Already the latest version."
}

########################################################################################################
# The script starts here - Functions first
########################################################################################################

# Lets make sure we have some tools we need.  If not then the script will try to install dnsutils, if it 
# fails then exit.
# Handle CLI to enable self-update and exit
RAW_ARGS=("$@")

# Detect REBOOT to skip self-update on early boot
is_reboot_run=0
for _a in "${RAW_ARGS[@]}"; do
  case "$_a" in
    --reboot|REBOOT) is_reboot_run=1; break;;
  esac
done

# Enable self-update by editing /usr/local/etc/log-my-ip.ini
enable_self_update_ini()
{
	local ini="/usr/local/etc/log-my-ip.ini"
	# Require root to write the INI
	if [ "$(id -u)" != "0" ]; then
		echo -e "${_RED}Must be root to modify ${ini}${_RESTORE}"
		return 1
	fi
	# Create file if missing with minimal content
	if [ ! -f "$ini" ]; then
		mkdir -p /usr/local/etc
		{
			echo "# Auto-generated by log-my-ip.sh --enable-self-update"
			echo "USE_SELFUPATE=YES"
			echo "GIT_BRANCH=\"main\""
		} > "$ini"
	else
		# Update or append USE_SELFUPATE
		if grep -q '^USE_SELFUPATE=' "$ini"; then
			sed -i 's/^USE_SELFUPATE=.*/USE_SELFUPATE=YES/' "$ini"
		else
			echo "USE_SELFUPATE=YES" >> "$ini"
		fi
		# Update or append GIT_BRANCH
		if grep -q '^GIT_BRANCH=' "$ini"; then
			sed -i 's/^GIT_BRANCH=.*/GIT_BRANCH="main"/' "$ini"
		else
			echo 'GIT_BRANCH="main"' >> "$ini"
		fi
	fi
	echo -e "${_GREEN}Enabled self-update in ${ini}${_RESTORE}"
}

# Test for dnsutils - we need the dig command
check_for_deps()
{
	which dig &> /dev/null
	_HAVE_DIG=$?
	which lsb_release &> /dev/null
	_HAVE_LSB=$?
	which curl &> /dev/null
	_HAVE_CURL=$?

	if [ ${_HAVE_DIG} = 1 ] || [ ${_HAVE_LSB} = 1 ] || [ ${_HAVE_CURL} = 1 ]; then
		echo -e "${_RED}Oh SNAP! Looks like you're missing some dependencies.${_RESTORE}"
		if [ ${_HAVE_DIG} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}dig${_RESTORE} command. Please install ${_GREEN}dnsutils${_RESTORE} on DEB systems,"
			echo -e "and ${_GREEN}bind-utils${_RESTORE} on RPM systems."
			echo
		fi
		if [ ${_HAVE_LSB} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}lsb_release${_RESTORE} command. Please install ${_GREEN}redhat-lsb-core${_RESTORE} in CentOS and RHEL."
			echo
		fi
		if [ ${_HAVE_CURL} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}curl${_RESTORE} command. Please install ${_GREEN}curl${_RESTORE}."
			echo
		fi
		exit 1
	fi
}

# Resolve external/public IPv4 address using multiple strategies (DNS + HTTPS fallbacks)
get_external_ip()
{
	local cand=""
	# Try DNS methods first, if dig is available
	if command -v dig >/dev/null 2>&1; then
		cand="$(dig +short -4 TXT o-o.myaddr.l.google.com @ns1.google.com 2>/dev/null | tr -d '"' | head -n1)"
		if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
			cand="$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null | head -n1)"
		fi
	fi

	# If DNS didn't work, try HTTPS-based services with curl
	if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		for url in \
			https://api.ipify.org \
			https://ifconfig.me/ip \
			https://icanhazip.com \
			https://checkip.amazonaws.com \
			https://ipinfo.io/ip
		do
			cand="$(curl -4 -fsS --max-time 3 --connect-timeout 2 "$url" 2>/dev/null | tr -d '\n\r\t ' | head -c 64)"
			if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
				break
			fi
		done
	fi

	if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		extip="$cand"
	else
		extip="Unknown"
	fi
}

send_message_to_telegram()
{
    tmpfile=$(mktemp /tmp/telebot.XXXXXXX)
    cat > $tmpfile <<EOF
{"chat_id":"$TGGRPID", "parse_mode":"markdown", "text":"*System Update*: $note\n*Date*: ${mydate}\n*Hostname*: $hostname\n*Internal IP*: $intip\n*External IP*: $extip"}
EOF
    curl -k --header 'Content-Type: application/json' \
        --data-binary @${tmpfile} \
        --request POST ${TGURL}
    rm -f $tmpfile
}

# This function will send our reboot message to a server where you have a script running to receive it.
send_message_to_server()
{
	PING=1
	while [ ${PING} -gt 0 ]
	do
		ping -c 5 ${_MYSERVER} &> /dev/null
		PING=$?
	done
	wget ${WGETOPTS} ${GCURL} --post-data="hostname=${hostname}&intip=${intip}&extip=${extip}&mydate=${mydate}&note=${note}"
	if [ "${note}" = "REBOOT" ];then
		send_message
	fi
}

self_update() {
    [ "$UPDATE_GUARD" ] && return
    export UPDATE_GUARD=YES
    command -v git >/dev/null 2>&1 || return
    if ! getent hosts github.com >/dev/null 2>&1; then
        return
    fi

	_SCRIPT=$(readlink -f "$0")
	_SCRIPTPATH=$(dirname "$_SCRIPT")
	_SCRIPTNAME="$0"

	(
		cd "$_SCRIPTPATH" || exit 0
		command -v git >/dev/null 2>&1 || exit 0
		git fetch --all --quiet || exit 0
		local _BRANCH
		_BRANCH=${GIT_BRANCH:-main}
		git show-ref --verify --quiet "refs/remotes/origin/${_BRANCH}" || exit 0
		local local_before remote_target local_after
		local_before=$(git rev-parse --verify HEAD 2>/dev/null) || exit 0
		remote_target=$(git rev-parse --verify "origin/${_BRANCH}" 2>/dev/null) || exit 0
		if [ "$local_before" != "$remote_target" ]; then
			echo "Found a new version of me, updating myself..."
			git checkout -q "${_BRANCH}" || true
			git pull --force -q || true
			local_after=$(git rev-parse --verify HEAD 2>/dev/null) || local_after="unknown"
			# Optionally send a Telegram notice about the update
			if [ -n "${TGTOKEN:-}" ] && [ -n "${TGGRPID:-}" ]; then
				__old_note="${note:-}"
				old_short=$(printf '%s' "$local_before" | cut -c1-7)
				new_short=$(printf '%s' "$local_after" | cut -c1-7)
				note="Self-update applied on ${hostname} (branch ${_BRANCH}): ${old_short} -> ${new_short}"
				send_message_to_telegram || true
				note="${__old_note}"
			fi
			echo "Running the new version..."
			exec "$_SCRIPT" "${ARGS}"
			exit 0
		fi
	)
	echo "Already the latest version."
}

########################################################################################################
# The script starts here - Functions first
########################################################################################################

# Lets make sure we have some tools we need.  If not then the script will try to install dnsutils, if it 
# fails then exit.
# Handle CLI to enable self-update and exit
RAW_ARGS=("$@")

# Detect REBOOT to skip self-update on early boot
is_reboot_run=0
for _a in "${RAW_ARGS[@]}"; do
  case "$_a" in
    --reboot|REBOOT) is_reboot_run=1; break;;
  esac
done

# Enable self-update by editing /usr/local/etc/log-my-ip.ini
enable_self_update_ini()
{
	local ini="/usr/local/etc/log-my-ip.ini"
	# Require root to write the INI
	if [ "$(id -u)" != "0" ]; then
		echo -e "${_RED}Must be root to modify ${ini}${_RESTORE}"
		return 1
	fi
	# Create file if missing with minimal content
	if [ ! -f "$ini" ]; then
		mkdir -p /usr/local/etc
		{
			echo "# Auto-generated by log-my-ip.sh --enable-self-update"
			echo "USE_SELFUPATE=YES"
			echo "GIT_BRANCH=\"main\""
		} > "$ini"
	else
		# Update or append USE_SELFUPATE
		if grep -q '^USE_SELFUPATE=' "$ini"; then
			sed -i 's/^USE_SELFUPATE=.*/USE_SELFUPATE=YES/' "$ini"
		else
			echo "USE_SELFUPATE=YES" >> "$ini"
		fi
		# Update or append GIT_BRANCH
		if grep -q '^GIT_BRANCH=' "$ini"; then
			sed -i 's/^GIT_BRANCH=.*/GIT_BRANCH="main"/' "$ini"
		else
			echo 'GIT_BRANCH="main"' >> "$ini"
		fi
	fi
	echo -e "${_GREEN}Enabled self-update in ${ini}${_RESTORE}"
}

# Test for dnsutils - we need the dig command
check_for_deps()
{
	which dig &> /dev/null
	_HAVE_DIG=$?
	which lsb_release &> /dev/null
	_HAVE_LSB=$?
	which curl &> /dev/null
	_HAVE_CURL=$?

	if [ ${_HAVE_DIG} = 1 ] || [ ${_HAVE_LSB} = 1 ] || [ ${_HAVE_CURL} = 1 ]; then
		echo -e "${_RED}Oh SNAP! Looks like you're missing some dependencies.${_RESTORE}"
		if [ ${_HAVE_DIG} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}dig${_RESTORE} command. Please install ${_GREEN}dnsutils${_RESTORE} on DEB systems,"
			echo -e "and ${_GREEN}bind-utils${_RESTORE} on RPM systems."
			echo
		fi
		if [ ${_HAVE_LSB} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}lsb_release${_RESTORE} command. Please install ${_GREEN}redhat-lsb-core${_RESTORE} in CentOS and RHEL."
			echo
		fi
		if [ ${_HAVE_CURL} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}curl${_RESTORE} command. Please install ${_GREEN}curl${_RESTORE}."
			echo
		fi
		exit 1
	fi
}

# Resolve external/public IPv4 address using multiple strategies (DNS + HTTPS fallbacks)
get_external_ip()
{
	local cand=""
	# Try DNS methods first, if dig is available
	if command -v dig >/dev/null 2>&1; then
		cand="$(dig +short -4 TXT o-o.myaddr.l.google.com @ns1.google.com 2>/dev/null | tr -d '"' | head -n1)"
		if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
			cand="$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null | head -n1)"
		fi
	fi

	# If DNS didn't work, try HTTPS-based services with curl
	if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		for url in \
			https://api.ipify.org \
			https://ifconfig.me/ip \
			https://icanhazip.com \
			https://checkip.amazonaws.com \
			https://ipinfo.io/ip
		do
			cand="$(curl -4 -fsS --max-time 3 --connect-timeout 2 "$url" 2>/dev/null | tr -d '\n\r\t ' | head -c 64)"
			if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
				break
			fi
		done
	fi

	if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		extip="$cand"
	else
		extip="Unknown"
	fi
}

send_message_to_telegram()
{
    tmpfile=$(mktemp /tmp/telebot.XXXXXXX)
    cat > $tmpfile <<EOF
{"chat_id":"$TGGRPID", "parse_mode":"markdown", "text":"*System Update*: $note\n*Date*: ${mydate}\n*Hostname*: $hostname\n*Internal IP*: $intip\n*External IP*: $extip"}
EOF
    curl -k --header 'Content-Type: application/json' \
        --data-binary @${tmpfile} \
        --request POST ${TGURL}
    rm -f $tmpfile
}

# This function will send our reboot message to a server where you have a script running to receive it.
send_message_to_server()
{
	PING=1
	while [ ${PING} -gt 0 ]
	do
		ping -c 5 ${_MYSERVER} &> /dev/null
		PING=$?
	done
	wget ${WGETOPTS} ${GCURL} --post-data="hostname=${hostname}&intip=${intip}&extip=${extip}&mydate=${mydate}&note=${note}"
	if [ "${note}" = "REBOOT" ];then
		send_message
	fi
}

self_update() {
    [ "$UPDATE_GUARD" ] && return
    export UPDATE_GUARD=YES
    command -v git >/dev/null 2>&1 || return
    if ! getent hosts github.com >/dev/null 2>&1; then
        return
    fi

	_SCRIPT=$(readlink -f "$0")
	_SCRIPTPATH=$(dirname "$_SCRIPT")
	_SCRIPTNAME="$0"

	(
		cd "$_SCRIPTPATH" || exit 0
		command -v git >/dev/null 2>&1 || exit 0
		git fetch --all --quiet || exit 0
		local _BRANCH
		_BRANCH=${GIT_BRANCH:-main}
		git show-ref --verify --quiet "refs/remotes/origin/${_BRANCH}" || exit 0
		local local_before remote_target local_after
		local_before=$(git rev-parse --verify HEAD 2>/dev/null) || exit 0
		remote_target=$(git rev-parse --verify "origin/${_BRANCH}" 2>/dev/null) || exit 0
		if [ "$local_before" != "$remote_target" ]; then
			echo "Found a new version of me, updating myself..."
			git checkout -q "${_BRANCH}" || true
			git pull --force -q || true
			local_after=$(git rev-parse --verify HEAD 2>/dev/null) || local_after="unknown"
			# Optionally send a Telegram notice about the update
			if [ -n "${TGTOKEN:-}" ] && [ -n "${TGGRPID:-}" ]; then
				__old_note="${note:-}"
				old_short=$(printf '%s' "$local_before" | cut -c1-7)
				new_short=$(printf '%s' "$local_after" | cut -c1-7)
				note="Self-update applied on ${hostname} (branch ${_BRANCH}): ${old_short} -> ${new_short}"
				send_message_to_telegram || true
				note="${__old_note}"
			fi
			echo "Running the new version..."
			exec "$_SCRIPT" "${ARGS}"
			exit 0
		fi
	)
	echo "Already the latest version."
}

########################################################################################################
# The script starts here - Functions first
########################################################################################################

# Lets make sure we have some tools we need.  If not then the script will try to install dnsutils, if it 
# fails then exit.
# Handle CLI to enable self-update and exit
RAW_ARGS=("$@")

# Detect REBOOT to skip self-update on early boot
is_reboot_run=0
for _a in "${RAW_ARGS[@]}"; do
  case "$_a" in
    --reboot|REBOOT) is_reboot_run=1; break;;
  esac
done

# Enable self-update by editing /usr/local/etc/log-my-ip.ini
enable_self_update_ini()
{
	local ini="/usr/local/etc/log-my-ip.ini"
	# Require root to write the INI
	if [ "$(id -u)" != "0" ]; then
		echo -e "${_RED}Must be root to modify ${ini}${_RESTORE}"
		return 1
	fi
	# Create file if missing with minimal content
	if [ ! -f "$ini" ]; then
		mkdir -p /usr/local/etc
		{
			echo "# Auto-generated by log-my-ip.sh --enable-self-update"
			echo "USE_SELFUPATE=YES"
			echo "GIT_BRANCH=\"main\""
		} > "$ini"
	else
		# Update or append USE_SELFUPATE
		if grep -q '^USE_SELFUPATE=' "$ini"; then
			sed -i 's/^USE_SELFUPATE=.*/USE_SELFUPATE=YES/' "$ini"
		else
			echo "USE_SELFUPATE=YES" >> "$ini"
		fi
		# Update or append GIT_BRANCH
		if grep -q '^GIT_BRANCH=' "$ini"; then
			sed -i 's/^GIT_BRANCH=.*/GIT_BRANCH="main"/' "$ini"
		else
			echo 'GIT_BRANCH="main"' >> "$ini"
		fi
	fi
	echo -e "${_GREEN}Enabled self-update in ${ini}${_RESTORE}"
}

# Test for dnsutils - we need the dig command
check_for_deps()
{
	which dig &> /dev/null
	_HAVE_DIG=$?
	which lsb_release &> /dev/null
	_HAVE_LSB=$?
	which curl &> /dev/null
	_HAVE_CURL=$?

	if [ ${_HAVE_DIG} = 1 ] || [ ${_HAVE_LSB} = 1 ] || [ ${_HAVE_CURL} = 1 ]; then
		echo -e "${_RED}Oh SNAP! Looks like you're missing some dependencies.${_RESTORE}"
		if [ ${_HAVE_DIG} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}dig${_RESTORE} command. Please install ${_GREEN}dnsutils${_RESTORE} on DEB systems,"
			echo -e "and ${_GREEN}bind-utils${_RESTORE} on RPM systems."
			echo
		fi
		if [ ${_HAVE_LSB} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}lsb_release${_RESTORE} command. Please install ${_GREEN}redhat-lsb-core${_RESTORE} in CentOS and RHEL."
			echo
		fi
		if [ ${_HAVE_CURL} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}curl${_RESTORE} command. Please install ${_GREEN}curl${_RESTORE}."
			echo
		fi
		exit 1
	fi
}

# Resolve external/public IPv4 address using multiple strategies (DNS + HTTPS fallbacks)
get_external_ip()
{
	local cand=""
	# Try DNS methods first, if dig is available
	if command -v dig >/dev/null 2>&1; then
		cand="$(dig +short -4 TXT o-o.myaddr.l.google.com @ns1.google.com 2>/dev/null | tr -d '"' | head -n1)"
		if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
			cand="$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null | head -n1)"
		fi
	fi

	# If DNS didn't work, try HTTPS-based services with curl
	if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		for url in \
			https://api.ipify.org \
			https://ifconfig.me/ip \
			https://icanhazip.com \
			https://checkip.amazonaws.com \
			https://ipinfo.io/ip
		do
			cand="$(curl -4 -fsS --max-time 3 --connect-timeout 2 "$url" 2>/dev/null | tr -d '\n\r\t ' | head -c 64)"
			if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
				break
			fi
		done
	fi

	if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		extip="$cand"
	else
		extip="Unknown"
	fi
}

send_message_to_telegram()
{
    tmpfile=$(mktemp /tmp/telebot.XXXXXXX)
    cat > $tmpfile <<EOF
{"chat_id":"$TGGRPID", "parse_mode":"markdown", "text":"*System Update*: $note\n*Date*: ${mydate}\n*Hostname*: $hostname\n*Internal IP*: $intip\n*External IP*: $extip"}
EOF
    curl -k --header 'Content-Type: application/json' \
        --data-binary @${tmpfile} \
        --request POST ${TGURL}
    rm -f $tmpfile
}

# This function will send our reboot message to a server where you have a script running to receive it.
send_message_to_server()
{
	PING=1
	while [ ${PING} -gt 0 ]
	do
		ping -c 5 ${_MYSERVER} &> /dev/null
		PING=$?
	done
	wget ${WGETOPTS} ${GCURL} --post-data="hostname=${hostname}&intip=${intip}&extip=${extip}&mydate=${mydate}&note=${note}"
	if [ "${note}" = "REBOOT" ];then
		send_message
	fi
}

self_update() {
    [ "$UPDATE_GUARD" ] && return
    export UPDATE_GUARD=YES
    command -v git >/dev/null 2>&1 || return
    if ! getent hosts github.com >/dev/null 2>&1; then
        return
    fi

	_SCRIPT=$(readlink -f "$0")
	_SCRIPTPATH=$(dirname "$_SCRIPT")
	_SCRIPTNAME="$0"

	(
		cd "$_SCRIPTPATH" || exit 0
		command -v git >/dev/null 2>&1 || exit 0
		git fetch --all --quiet || exit 0
		local _BRANCH
		_BRANCH=${GIT_BRANCH:-main}
		git show-ref --verify --quiet "refs/remotes/origin/${_BRANCH}" || exit 0
		local local_before remote_target local_after
		local_before=$(git rev-parse --verify HEAD 2>/dev/null) || exit 0
		remote_target=$(git rev-parse --verify "origin/${_BRANCH}" 2>/dev/null) || exit 0
		if [ "$local_before" != "$remote_target" ]; then
			echo "Found a new version of me, updating myself..."
			git checkout -q "${_BRANCH}" || true
			git pull --force -q || true
			local_after=$(git rev-parse --verify HEAD 2>/dev/null) || local_after="unknown"
			# Optionally send a Telegram notice about the update
			if [ -n "${TGTOKEN:-}" ] && [ -n "${TGGRPID:-}" ]; then
				__old_note="${note:-}"
				old_short=$(printf '%s' "$local_before" | cut -c1-7)
				new_short=$(printf '%s' "$local_after" | cut -c1-7)
				note="Self-update applied on ${hostname} (branch ${_BRANCH}): ${old_short} -> ${new_short}"
				send_message_to_telegram || true
				note="${__old_note}"
			fi
			echo "Running the new version..."
			exec "$_SCRIPT" "${ARGS}"
			exit 0
		fi
	)
	echo "Already the latest version."
}

########################################################################################################
# The script starts here - Functions first
########################################################################################################

# Lets make sure we have some tools we need.  If not then the script will try to install dnsutils, if it 
# fails then exit.
# Handle CLI to enable self-update and exit
RAW_ARGS=("$@")

# Detect REBOOT to skip self-update on early boot
is_reboot_run=0
for _a in "${RAW_ARGS[@]}"; do
  case "$_a" in
    --reboot|REBOOT) is_reboot_run=1; break;;
  esac
done

# Enable self-update by editing /usr/local/etc/log-my-ip.ini
enable_self_update_ini()
{
	local ini="/usr/local/etc/log-my-ip.ini"
	# Require root to write the INI
	if [ "$(id -u)" != "0" ]; then
		echo -e "${_RED}Must be root to modify ${ini}${_RESTORE}"
		return 1
	fi
	# Create file if missing with minimal content
	if [ ! -f "$ini" ]; then
		mkdir -p /usr/local/etc
		{
			echo "# Auto-generated by log-my-ip.sh --enable-self-update"
			echo "USE_SELFUPATE=YES"
			echo "GIT_BRANCH=\"main\""
		} > "$ini"
	else
		# Update or append USE_SELFUPATE
		if grep -q '^USE_SELFUPATE=' "$ini"; then
			sed -i 's/^USE_SELFUPATE=.*/USE_SELFUPATE=YES/' "$ini"
		else
			echo "USE_SELFUPATE=YES" >> "$ini"
		fi
		# Update or append GIT_BRANCH
		if grep -q '^GIT_BRANCH=' "$ini"; then
			sed -i 's/^GIT_BRANCH=.*/GIT_BRANCH="main"/' "$ini"
		else
			echo 'GIT_BRANCH="main"' >> "$ini"
		fi
	fi
	echo -e "${_GREEN}Enabled self-update in ${ini}${_RESTORE}"
}

# Test for dnsutils - we need the dig command
check_for_deps()
{
	which dig &> /dev/null
	_HAVE_DIG=$?
	which lsb_release &> /dev/null
	_HAVE_LSB=$?
	which curl &> /dev/null
	_HAVE_CURL=$?

	if [ ${_HAVE_DIG} = 1 ] || [ ${_HAVE_LSB} = 1 ] || [ ${_HAVE_CURL} = 1 ]; then
		echo -e "${_RED}Oh SNAP! Looks like you're missing some dependencies.${_RESTORE}"
		if [ ${_HAVE_DIG} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}dig${_RESTORE} command. Please install ${_GREEN}dnsutils${_RESTORE} on DEB systems,"
			echo -e "and ${_GREEN}bind-utils${_RESTORE} on RPM systems."
			echo
		fi
		if [ ${_HAVE_LSB} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}lsb_release${_RESTORE} command. Please install ${_GREEN}redhat-lsb-core${_RESTORE} in CentOS and RHEL."
			echo
		fi
		if [ ${_HAVE_CURL} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}curl${_RESTORE} command. Please install ${_GREEN}curl${_RESTORE}."
			echo
		fi
		exit 1
	fi
}

# Resolve external/public IPv4 address using multiple strategies (DNS + HTTPS fallbacks)
get_external_ip()
{
	local cand=""
	# Try DNS methods first, if dig is available
	if command -v dig >/dev/null 2>&1; then
		cand="$(dig +short -4 TXT o-o.myaddr.l.google.com @ns1.google.com 2>/dev/null | tr -d '"' | head -n1)"
		if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
			cand="$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null | head -n1)"
		fi
	fi

	# If DNS didn't work, try HTTPS-based services with curl
	if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		for url in \
			https://api.ipify.org \
			https://ifconfig.me/ip \
			https://icanhazip.com \
			https://checkip.amazonaws.com \
			https://ipinfo.io/ip
		do
			cand="$(curl -4 -fsS --max-time 3 --connect-timeout 2 "$url" 2>/dev/null | tr -d '\n\r\t ' | head -c 64)"
			if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
				break
			fi
		done
	fi

	if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		extip="$cand"
	else
		extip="Unknown"
	fi
}

send_message_to_telegram()
{
    tmpfile=$(mktemp /tmp/telebot.XXXXXXX)
    cat > $tmpfile <<EOF
{"chat_id":"$TGGRPID", "parse_mode":"markdown", "text":"*System Update*: $note\n*Date*: ${mydate}\n*Hostname*: $hostname\n*Internal IP*: $intip\n*External IP*: $extip"}
EOF
    curl -k --header 'Content-Type: application/json' \
        --data-binary @${tmpfile} \
        --request POST ${TGURL}
    rm -f $tmpfile
}

# This function will send our reboot message to a server where you have a script running to receive it.
send_message_to_server()
{
	PING=1
	while [ ${PING} -gt 0 ]
	do
		ping -c 5 ${_MYSERVER} &> /dev/null
		PING=$?
	done
	wget ${WGETOPTS} ${GCURL} --post-data="hostname=${hostname}&intip=${intip}&extip=${extip}&mydate=${mydate}&note=${note}"
	if [ "${note}" = "REBOOT" ];then
		send_message
	fi
}

self_update() {
    [ "$UPDATE_GUARD" ] && return
    export UPDATE_GUARD=YES
    command -v git >/dev/null 2>&1 || return
    if ! getent hosts github.com >/dev/null 2>&1; then
        return
    fi

	_SCRIPT=$(readlink -f "$0")
	_SCRIPTPATH=$(dirname "$_SCRIPT")
	_SCRIPTNAME="$0"

	(
		cd "$_SCRIPTPATH" || exit 0
		command -v git >/dev/null 2>&1 || exit 0
		git fetch --all --quiet || exit 0
		local _BRANCH
		_BRANCH=${GIT_BRANCH:-main}
		git show-ref --verify --quiet "refs/remotes/origin/${_BRANCH}" || exit 0
		local local_before remote_target local_after
		local_before=$(git rev-parse --verify HEAD 2>/dev/null) || exit 0
		remote_target=$(git rev-parse --verify "origin/${_BRANCH}" 2>/dev/null) || exit 0
		if [ "$local_before" != "$remote_target" ]; then
			echo "Found a new version of me, updating myself..."
			git checkout -q "${_BRANCH}" || true
			git pull --force -q || true
			local_after=$(git rev-parse --verify HEAD 2>/dev/null) || local_after="unknown"
			# Optionally send a Telegram notice about the update
			if [ -n "${TGTOKEN:-}" ] && [ -n "${TGGRPID:-}" ]; then
				__old_note="${note:-}"
				old_short=$(printf '%s' "$local_before" | cut -c1-7)
				new_short=$(printf '%s' "$local_after" | cut -c1-7)
				note="Self-update applied on ${hostname} (branch ${_BRANCH}): ${old_short} -> ${new_short}"
				send_message_to_telegram || true
				note="${__old_note}"
			fi
			echo "Running the new version..."
			exec "$_SCRIPT" "${ARGS}"
			exit 0
		fi
	)
	echo "Already the latest version."
}

########################################################################################################
# The script starts here - Functions first
########################################################################################################

# Lets make sure we have some tools we need.  If not then the script will try to install dnsutils, if it 
# fails then exit.
# Handle CLI to enable self-update and exit
RAW_ARGS=("$@")

# Detect REBOOT to skip self-update on early boot
is_reboot_run=0
for _a in "${RAW_ARGS[@]}"; do
  case "$_a" in
    --reboot|REBOOT) is_reboot_run=1; break;;
  esac
done

# Enable self-update by editing /usr/local/etc/log-my-ip.ini
enable_self_update_ini()
{
	local ini="/usr/local/etc/log-my-ip.ini"
	# Require root to write the INI
	if [ "$(id -u)" != "0" ]; then
		echo -e "${_RED}Must be root to modify ${ini}${_RESTORE}"
		return 1
	fi
	# Create file if missing with minimal content
	if [ ! -f "$ini" ]; then
		mkdir -p /usr/local/etc
		{
			echo "# Auto-generated by log-my-ip.sh --enable-self-update"
			echo "USE_SELFUPATE=YES"
			echo "GIT_BRANCH=\"main\""
		} > "$ini"
	else
		# Update or append USE_SELFUPATE
		if grep -q '^USE_SELFUPATE=' "$ini"; then
			sed -i 's/^USE_SELFUPATE=.*/USE_SELFUPATE=YES/' "$ini"
		else
			echo "USE_SELFUPATE=YES" >> "$ini"
		fi
		# Update or append GIT_BRANCH
		if grep -q '^GIT_BRANCH=' "$ini"; then
			sed -i 's/^GIT_BRANCH=.*/GIT_BRANCH="main"/' "$ini"
		else
			echo 'GIT_BRANCH="main"' >> "$ini"
		fi
	fi
	echo -e "${_GREEN}Enabled self-update in ${ini}${_RESTORE}"
}

# Test for dnsutils - we need the dig command
check_for_deps()
{
	which dig &> /dev/null
	_HAVE_DIG=$?
	which lsb_release &> /dev/null
	_HAVE_LSB=$?
	which curl &> /dev/null
	_HAVE_CURL=$?

	if [ ${_HAVE_DIG} = 1 ] || [ ${_HAVE_LSB} = 1 ] || [ ${_HAVE_CURL} = 1 ]; then
		echo -e "${_RED}Oh SNAP! Looks like you're missing some dependencies.${_RESTORE}"
		if [ ${_HAVE_DIG} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}dig${_RESTORE} command. Please install ${_GREEN}dnsutils${_RESTORE} on DEB systems,"
			echo -e "and ${_GREEN}bind-utils${_RESTORE} on RPM systems."
			echo
		fi
		if [ ${_HAVE_LSB} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}lsb_release${_RESTORE} command. Please install ${_GREEN}redhat-lsb-core${_RESTORE} in CentOS and RHEL."
			echo
		fi
		if [ ${_HAVE_CURL} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}curl${_RESTORE} command. Please install ${_GREEN}curl${_RESTORE}."
			echo
		fi
		exit 1
	fi
}

# Resolve external/public IPv4 address using multiple strategies (DNS + HTTPS fallbacks)
get_external_ip()
{
	local cand=""
	# Try DNS methods first, if dig is available
	if command -v dig >/dev/null 2>&1; then
		cand="$(dig +short -4 TXT o-o.myaddr.l.google.com @ns1.google.com 2>/dev/null | tr -d '"' | head -n1)"
		if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
			cand="$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null | head -n1)"
		fi
	fi

	# If DNS didn't work, try HTTPS-based services with curl
	if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		for url in \
			https://api.ipify.org \
			https://ifconfig.me/ip \
			https://icanhazip.com \
			https://checkip.amazonaws.com \
			https://ipinfo.io/ip
		do
			cand="$(curl -4 -fsS --max-time 3 --connect-timeout 2 "$url" 2>/dev/null | tr -d '\n\r\t ' | head -c 64)"
			if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
				break
			fi
		done
	fi

	if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		extip="$cand"
	else
		extip="Unknown"
	fi
}

send_message_to_telegram()
{
    tmpfile=$(mktemp /tmp/telebot.XXXXXXX)
    cat > $tmpfile <<EOF
{"chat_id":"$TGGRPID", "parse_mode":"markdown", "text":"*System Update*: $note\n*Date*: ${mydate}\n*Hostname*: $hostname\n*Internal IP*: $intip\n*External IP*: $extip"}
EOF
    curl -k --header 'Content-Type: application/json' \
        --data-binary @${tmpfile} \
        --request POST ${TGURL}
    rm -f $tmpfile
}

# This function will send our reboot message to a server where you have a script running to receive it.
send_message_to_server()
{
	PING=1
	while [ ${PING} -gt 0 ]
	do
		ping -c 5 ${_MYSERVER} &> /dev/null
		PING=$?
	done
	wget ${WGETOPTS} ${GCURL} --post-data="hostname=${hostname}&intip=${intip}&extip=${extip}&mydate=${mydate}&note=${note}"
	if [ "${note}" = "REBOOT" ];then
		send_message
	fi
}

self_update() {
    [ "$UPDATE_GUARD" ] && return
    export UPDATE_GUARD=YES
    command -v git >/dev/null 2>&1 || return
    if ! getent hosts github.com >/dev/null 2>&1; then
        return
    fi

	_SCRIPT=$(readlink -f "$0")
	_SCRIPTPATH=$(dirname "$_SCRIPT")
	_SCRIPTNAME="$0"

	(
		cd "$_SCRIPTPATH" || exit 0
		command -v git >/dev/null 2>&1 || exit 0
		git fetch --all --quiet || exit 0
		local _BRANCH
		_BRANCH=${GIT_BRANCH:-main}
		git show-ref --verify --quiet "refs/remotes/origin/${_BRANCH}" || exit 0
		local local_before remote_target local_after
		local_before=$(git rev-parse --verify HEAD 2>/dev/null) || exit 0
		remote_target=$(git rev-parse --verify "origin/${_BRANCH}" 2>/dev/null) || exit 0
		if [ "$local_before" != "$remote_target" ]; then
			echo "Found a new version of me, updating myself..."
			git checkout -q "${_BRANCH}" || true
			git pull --force -q || true
			local_after=$(git rev-parse --verify HEAD 2>/dev/null) || local_after="unknown"
			# Optionally send a Telegram notice about the update
			if [ -n "${TGTOKEN:-}" ] && [ -n "${TGGRPID:-}" ]; then
				__old_note="${note:-}"
				old_short=$(printf '%s' "$local_before" | cut -c1-7)
				new_short=$(printf '%s' "$local_after" | cut -c1-7)
				note="Self-update applied on ${hostname} (branch ${_BRANCH}): ${old_short} -> ${new_short}"
				send_message_to_telegram || true
				note="${__old_note}"
			fi
			echo "Running the new version..."
			exec "$_SCRIPT" "${ARGS}"
			exit 0
		fi
	)
	echo "Already the latest version."
}

########################################################################################################
# The script starts here - Functions first
########################################################################################################

# Lets make sure we have some tools we need.  If not then the script will try to install dnsutils, if it 
# fails then exit.
# Handle CLI to enable self-update and exit
RAW_ARGS=("$@")

# Detect REBOOT to skip self-update on early boot
is_reboot_run=0
for _a in "${RAW_ARGS[@]}"; do
  case "$_a" in
    --reboot|REBOOT) is_reboot_run=1; break;;
  esac
done

# Enable self-update by editing /usr/local/etc/log-my-ip.ini
enable_self_update_ini()
{
	local ini="/usr/local/etc/log-my-ip.ini"
	# Require root to write the INI
	if [ "$(id -u)" != "0" ]; then
		echo -e "${_RED}Must be root to modify ${ini}${_RESTORE}"
		return 1
	fi
	# Create file if missing with minimal content
	if [ ! -f "$ini" ]; then
		mkdir -p /usr/local/etc
		{
			echo "# Auto-generated by log-my-ip.sh --enable-self-update"
			echo "USE_SELFUPATE=YES"
			echo "GIT_BRANCH=\"main\""
		} > "$ini"
	else
		# Update or append USE_SELFUPATE
		if grep -q '^USE_SELFUPATE=' "$ini"; then
			sed -i 's/^USE_SELFUPATE=.*/USE_SELFUPATE=YES/' "$ini"
		else
			echo "USE_SELFUPATE=YES" >> "$ini"
		fi
		# Update or append GIT_BRANCH
		if grep -q '^GIT_BRANCH=' "$ini"; then
			sed -i 's/^GIT_BRANCH=.*/GIT_BRANCH="main"/' "$ini"
		else
			echo 'GIT_BRANCH="main"' >> "$ini"
		fi
	fi
	echo -e "${_GREEN}Enabled self-update in ${ini}${_RESTORE}"
}

# Test for dnsutils - we need the dig command
check_for_deps()
{
	which dig &> /dev/null
	_HAVE_DIG=$?
	which lsb_release &> /dev/null
	_HAVE_LSB=$?
	which curl &> /dev/null
	_HAVE_CURL=$?

	if [ ${_HAVE_DIG} = 1 ] || [ ${_HAVE_LSB} = 1 ] || [ ${_HAVE_CURL} = 1 ]; then
		echo -e "${_RED}Oh SNAP! Looks like you're missing some dependencies.${_RESTORE}"
		if [ ${_HAVE_DIG} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}dig${_RESTORE} command. Please install ${_GREEN}dnsutils${_RESTORE} on DEB systems,"
			echo -e "and ${_GREEN}bind-utils${_RESTORE} on RPM systems."
			echo
		fi
		if [ ${_HAVE_LSB} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}lsb_release${_RESTORE} command. Please install ${_GREEN}redhat-lsb-core${_RESTORE} in CentOS and RHEL."
			echo
		fi
		if [ ${_HAVE_CURL} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}curl${_RESTORE} command. Please install ${_GREEN}curl${_RESTORE}."
			echo
		fi
		exit 1
	fi
}

# Resolve external/public IPv4 address using multiple strategies (DNS + HTTPS fallbacks)
get_external_ip()
{
	local cand=""
	# Try DNS methods first, if dig is available
	if command -v dig >/dev/null 2>&1; then
		cand="$(dig +short -4 TXT o-o.myaddr.l.google.com @ns1.google.com 2>/dev/null | tr -d '"' | head -n1)"
		if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
			cand="$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null | head -n1)"
		fi
	fi

	# If DNS didn't work, try HTTPS-based services with curl
	if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		for url in \
			https://api.ipify.org \
			https://ifconfig.me/ip \
			https://icanhazip.com \
			https://checkip.amazonaws.com \
			https://ipinfo.io/ip
		do
			cand="$(curl -4 -fsS --max-time 3 --connect-timeout 2 "$url" 2>/dev/null | tr -d '\n\r\t ' | head -c 64)"
			if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
				break
			fi
		done
	fi

	if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		extip="$cand"
	else
		extip="Unknown"
	fi
}

send_message_to_telegram()
{
    tmpfile=$(mktemp /tmp/telebot.XXXXXXX)
    cat > $tmpfile <<EOF
{"chat_id":"$TGGRPID", "parse_mode":"markdown", "text":"*System Update*: $note\n*Date*: ${mydate}\n*Hostname*: $hostname\n*Internal IP*: $intip\n*External IP*: $extip"}
EOF
    curl -k --header 'Content-Type: application/json' \
        --data-binary @${tmpfile} \
        --request POST ${TGURL}
    rm -f $tmpfile
}

# This function will send our reboot message to a server where you have a script running to receive it.
send_message_to_server()
{
	PING=1
	while [ ${PING} -gt 0 ]
	do
		ping -c 5 ${_MYSERVER} &> /dev/null
		PING=$?
	done
	wget ${WGETOPTS} ${GCURL} --post-data="hostname=${hostname}&intip=${intip}&extip=${extip}&mydate=${mydate}&note=${note}"
	if [ "${note}" = "REBOOT" ];then
		send_message
	fi
}

self_update() {
    [ "$UPDATE_GUARD" ] && return
    export UPDATE_GUARD=YES
    command -v git >/dev/null 2>&1 || return
    if ! getent hosts github.com >/dev/null 2>&1; then
        return
    fi

	_SCRIPT=$(readlink -f "$0")
	_SCRIPTPATH=$(dirname "$_SCRIPT")
	_SCRIPTNAME="$0"

	(
		cd "$_SCRIPTPATH" || exit 0
		command -v git >/dev/null 2>&1 || exit 0
		git fetch --all --quiet || exit 0
		local _BRANCH
		_BRANCH=${GIT_BRANCH:-main}
		git show-ref --verify --quiet "refs/remotes/origin/${_BRANCH}" || exit 0
		local local_before remote_target local_after
		local_before=$(git rev-parse --verify HEAD 2>/dev/null) || exit 0
		remote_target=$(git rev-parse --verify "origin/${_BRANCH}" 2>/dev/null) || exit 0
		if [ "$local_before" != "$remote_target" ]; then
			echo "Found a new version of me, updating myself..."
			git checkout -q "${_BRANCH}" || true
			git pull --force -q || true
			local_after=$(git rev-parse --verify HEAD 2>/dev/null) || local_after="unknown"
			# Optionally send a Telegram notice about the update
			if [ -n "${TGTOKEN:-}" ] && [ -n "${TGGRPID:-}" ]; then
				__old_note="${note:-}"
				old_short=$(printf '%s' "$local_before" | cut -c1-7)
				new_short=$(printf '%s' "$local_after" | cut -c1-7)
				note="Self-update applied on ${hostname} (branch ${_BRANCH}): ${old_short} -> ${new_short}"
				send_message_to_telegram || true
				note="${__old_note}"
			fi
			echo "Running the new version..."
			exec "$_SCRIPT" "${ARGS}"
			exit 0
		fi
	)
	echo "Already the latest version."
}

########################################################################################################
# The script starts here - Functions first
########################################################################################################

# Lets make sure we have some tools we need.  If not then the script will try to install dnsutils, if it 
# fails then exit.
# Handle CLI to enable self-update and exit
RAW_ARGS=("$@")

# Detect REBOOT to skip self-update on early boot
is_reboot_run=0
for _a in "${RAW_ARGS[@]}"; do
  case "$_a" in
    --reboot|REBOOT) is_reboot_run=1; break;;
  esac
done

# Enable self-update by editing /usr/local/etc/log-my-ip.ini
enable_self_update_ini()
{
	local ini="/usr/local/etc/log-my-ip.ini"
	# Require root to write the INI
	if [ "$(id -u)" != "0" ]; then
		echo -e "${_RED}Must be root to modify ${ini}${_RESTORE}"
		return 1
	fi
	# Create file if missing with minimal content
	if [ ! -f "$ini" ]; then
		mkdir -p /usr/local/etc
		{
			echo "# Auto-generated by log-my-ip.sh --enable-self-update"
			echo "USE_SELFUPATE=YES"
			echo "GIT_BRANCH=\"main\""
		} > "$ini"
	else
		# Update or append USE_SELFUPATE
		if grep -q '^USE_SELFUPATE=' "$ini"; then
			sed -i 's/^USE_SELFUPATE=.*/USE_SELFUPATE=YES/' "$ini"
		else
			echo "USE_SELFUPATE=YES" >> "$ini"
		fi
		# Update or append GIT_BRANCH
		if grep -q '^GIT_BRANCH=' "$ini"; then
			sed -i 's/^GIT_BRANCH=.*/GIT_BRANCH="main"/' "$ini"
		else
			echo 'GIT_BRANCH="main"' >> "$ini"
		fi
	fi
	echo -e "${_GREEN}Enabled self-update in ${ini}${_RESTORE}"
}

# Test for dnsutils - we need the dig command
check_for_deps()
{
	which dig &> /dev/null
	_HAVE_DIG=$?
	which lsb_release &> /dev/null
	_HAVE_LSB=$?
	which curl &> /dev/null
	_HAVE_CURL=$?

	if [ ${_HAVE_DIG} = 1 ] || [ ${_HAVE_LSB} = 1 ] || [ ${_HAVE_CURL} = 1 ]; then
		echo -e "${_RED}Oh SNAP! Looks like you're missing some dependencies.${_RESTORE}"
		if [ ${_HAVE_DIG} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}dig${_RESTORE} command. Please install ${_GREEN}dnsutils${_RESTORE} on DEB systems,"
			echo -e "and ${_GREEN}bind-utils${_RESTORE} on RPM systems."
			echo
		fi
		if [ ${_HAVE_LSB} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}lsb_release${_RESTORE} command. Please install ${_GREEN}redhat-lsb-core${_RESTORE} in CentOS and RHEL."
			echo
		fi
		if [ ${_HAVE_CURL} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}curl${_RESTORE} command. Please install ${_GREEN}curl${_RESTORE}."
			echo
		fi
		exit 1
	fi
}

# Resolve external/public IPv4 address using multiple strategies (DNS + HTTPS fallbacks)
get_external_ip()
{
	local cand=""
	# Try DNS methods first, if dig is available
	if command -v dig >/dev/null 2>&1; then
		cand="$(dig +short -4 TXT o-o.myaddr.l.google.com @ns1.google.com 2>/dev/null | tr -d '"' | head -n1)"
		if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
			cand="$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null | head -n1)"
		fi
	fi

	# If DNS didn't work, try HTTPS-based services with curl
	if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		for url in \
			https://api.ipify.org \
			https://ifconfig.me/ip \
			https://icanhazip.com \
			https://checkip.amazonaws.com \
			https://ipinfo.io/ip
		do
			cand="$(curl -4 -fsS --max-time 3 --connect-timeout 2 "$url" 2>/dev/null | tr -d '\n\r\t ' | head -c 64)"
			if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
				break
			fi
		done
	fi

	if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		extip="$cand"
	else
		extip="Unknown"
	fi
}

send_message_to_telegram()
{
    tmpfile=$(mktemp /tmp/telebot.XXXXXXX)
    cat > $tmpfile <<EOF
{"chat_id":"$TGGRPID", "parse_mode":"markdown", "text":"*System Update*: $note\n*Date*: ${mydate}\n*Hostname*: $hostname\n*Internal IP*: $intip\n*External IP*: $extip"}
EOF
    curl -k --header 'Content-Type: application/json' \
        --data-binary @${tmpfile} \
        --request POST ${TGURL}
    rm -f $tmpfile
}

# This function will send our reboot message to a server where you have a script running to receive it.
send_message_to_server()
{
	PING=1
	while [ ${PING} -gt 0 ]
	do
		ping -c 5 ${_MYSERVER} &> /dev/null
		PING=$?
	done
	wget ${WGETOPTS} ${GCURL} --post-data="hostname=${hostname}&intip=${intip}&extip=${extip}&mydate=${mydate}&note=${note}"
	if [ "${note}" = "REBOOT" ];then
		send_message
	fi
}

self_update() {
    [ "$UPDATE_GUARD" ] && return
    export UPDATE_GUARD=YES
    command -v git >/dev/null 2>&1 || return
    if ! getent hosts github.com >/dev/null 2>&1; then
        return
    fi

	_SCRIPT=$(readlink -f "$0")
	_SCRIPTPATH=$(dirname "$_SCRIPT")
	_SCRIPTNAME="$0"

	(
		cd "$_SCRIPTPATH" || exit 0
		command -v git >/dev/null 2>&1 || exit 0
		git fetch --all --quiet || exit 0
		local _BRANCH
		_BRANCH=${GIT_BRANCH:-main}
		git show-ref --verify --quiet "refs/remotes/origin/${_BRANCH}" || exit 0
		local local_before remote_target local_after
		local_before=$(git rev-parse --verify HEAD 2>/dev/null) || exit 0
		remote_target=$(git rev-parse --verify "origin/${_BRANCH}" 2>/dev/null) || exit 0
		if [ "$local_before" != "$remote_target" ]; then
			echo "Found a new version of me, updating myself..."
			git checkout -q "${_BRANCH}" || true
			git pull --force -q || true
			local_after=$(git rev-parse --verify HEAD 2>/dev/null) || local_after="unknown"
			# Optionally send a Telegram notice about the update
			if [ -n "${TGTOKEN:-}" ] && [ -n "${TGGRPID:-}" ]; then
				__old_note="${note:-}"
				old_short=$(printf '%s' "$local_before" | cut -c1-7)
				new_short=$(printf '%s' "$local_after" | cut -c1-7)
				note="Self-update applied on ${hostname} (branch ${_BRANCH}): ${old_short} -> ${new_short}"
				send_message_to_telegram || true
				note="${__old_note}"
			fi
			echo "Running the new version..."
			exec "$_SCRIPT" "${ARGS}"
			exit 0
		fi
	)
	echo "Already the latest version."
}

########################################################################################################
# The script starts here - Functions first
########################################################################################################

# Lets make sure we have some tools we need.  If not then the script will try to install dnsutils, if it 
# fails then exit.
# Handle CLI to enable self-update and exit
RAW_ARGS=("$@")

# Detect REBOOT to skip self-update on early boot
is_reboot_run=0
for _a in "${RAW_ARGS[@]}"; do
  case "$_a" in
    --reboot|REBOOT) is_reboot_run=1; break;;
  esac
done

# Enable self-update by editing /usr/local/etc/log-my-ip.ini
enable_self_update_ini()
{
	local ini="/usr/local/etc/log-my-ip.ini"
	# Require root to write the INI
	if [ "$(id -u)" != "0" ]; then
		echo -e "${_RED}Must be root to modify ${ini}${_RESTORE}"
		return 1
	fi
	# Create file if missing with minimal content
	if [ ! -f "$ini" ]; then
		mkdir -p /usr/local/etc
		{
			echo "# Auto-generated by log-my-ip.sh --enable-self-update"
			echo "USE_SELFUPATE=YES"
			echo "GIT_BRANCH=\"main\""
		} > "$ini"
	else
		# Update or append USE_SELFUPATE
		if grep -q '^USE_SELFUPATE=' "$ini"; then
			sed -i 's/^USE_SELFUPATE=.*/USE_SELFUPATE=YES/' "$ini"
		else
			echo "USE_SELFUPATE=YES" >> "$ini"
		fi
		# Update or append GIT_BRANCH
		if grep -q '^GIT_BRANCH=' "$ini"; then
			sed -i 's/^GIT_BRANCH=.*/GIT_BRANCH="main"/' "$ini"
		else
			echo 'GIT_BRANCH="main"' >> "$ini"
		fi
	fi
	echo -e "${_GREEN}Enabled self-update in ${ini}${_RESTORE}"
}

# Test for dnsutils - we need the dig command
check_for_deps()
{
	which dig &> /dev/null
	_HAVE_DIG=$?
	which lsb_release &> /dev/null
	_HAVE_LSB=$?
	which curl &> /dev/null
	_HAVE_CURL=$?

	if [ ${_HAVE_DIG} = 1 ] || [ ${_HAVE_LSB} = 1 ] || [ ${_HAVE_CURL} = 1 ]; then
		echo -e "${_RED}Oh SNAP! Looks like you're missing some dependencies.${_RESTORE}"
		if [ ${_HAVE_DIG} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}dig${_RESTORE} command. Please install ${_GREEN}dnsutils${_RESTORE} on DEB systems,"
			echo -e "and ${_GREEN}bind-utils${_RESTORE} on RPM systems."
			echo
		fi
		if [ ${_HAVE_LSB} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}lsb_release${_RESTORE} command. Please install ${_GREEN}redhat-lsb-core${_RESTORE} in CentOS and RHEL."
			echo
		fi
		if [ ${_HAVE_CURL} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}curl${_RESTORE} command. Please install ${_GREEN}curl${_RESTORE}."
			echo
		fi
		exit 1
	fi
}

# Resolve external/public IPv4 address using multiple strategies (DNS + HTTPS fallbacks)
get_external_ip()
{
	local cand=""
	# Try DNS methods first, if dig is available
	if command -v dig >/dev/null 2>&1; then
		cand="$(dig +short -4 TXT o-o.myaddr.l.google.com @ns1.google.com 2>/dev/null | tr -d '"' | head -n1)"
		if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
			cand="$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null | head -n1)"
		fi
	fi

	# If DNS didn't work, try HTTPS-based services with curl
	if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		for url in \
			https://api.ipify.org \
			https://ifconfig.me/ip \
			https://icanhazip.com \
			https://checkip.amazonaws.com \
			https://ipinfo.io/ip
		do
			cand="$(curl -4 -fsS --max-time 3 --connect-timeout 2 "$url" 2>/dev/null | tr -d '\n\r\t ' | head -c 64)"
			if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
				break
			fi
		done
	fi

	if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		extip="$cand"
	else
		extip="Unknown"
	fi
}

send_message_to_telegram()
{
    tmpfile=$(mktemp /tmp/telebot.XXXXXXX)
    cat > $tmpfile <<EOF
{"chat_id":"$TGGRPID", "parse_mode":"markdown", "text":"*System Update*: $note\n*Date*: ${mydate}\n*Hostname*: $hostname\n*Internal IP*: $intip\n*External IP*: $extip"}
EOF
    curl -k --header 'Content-Type: application/json' \
        --data-binary @${tmpfile} \
        --request POST ${TGURL}
    rm -f $tmpfile
}

# This function will send our reboot message to a server where you have a script running to receive it.
send_message_to_server()
{
	PING=1
	while [ ${PING} -gt 0 ]
	do
		ping -c 5 ${_MYSERVER} &> /dev/null
		PING=$?
	done
	wget ${WGETOPTS} ${GCURL} --post-data="hostname=${hostname}&intip=${intip}&extip=${extip}&mydate=${mydate}&note=${note}"
	if [ "${note}" = "REBOOT" ];then
		send_message
	fi
}

self_update() {
    [ "$UPDATE_GUARD" ] && return
    export UPDATE_GUARD=YES
    command -v git >/dev/null 2>&1 || return
    if ! getent hosts github.com >/dev/null 2>&1; then
        return
    fi

	_SCRIPT=$(readlink -f "$0")
	_SCRIPTPATH=$(dirname "$_SCRIPT")
	_SCRIPTNAME="$0"

	(
		cd "$_SCRIPTPATH" || exit 0
		command -v git >/dev/null 2>&1 || exit 0
		git fetch --all --quiet || exit 0
		local _BRANCH
		_BRANCH=${GIT_BRANCH:-main}
		git show-ref --verify --quiet "refs/remotes/origin/${_BRANCH}" || exit 0
		local local_before remote_target local_after
		local_before=$(git rev-parse --verify HEAD 2>/dev/null) || exit 0
		remote_target=$(git rev-parse --verify "origin/${_BRANCH}" 2>/dev/null) || exit 0
		if [ "$local_before" != "$remote_target" ]; then
			echo "Found a new version of me, updating myself..."
			git checkout -q "${_BRANCH}" || true
			git pull --force -q || true
			local_after=$(git rev-parse --verify HEAD 2>/dev/null) || local_after="unknown"
			# Optionally send a Telegram notice about the update
			if [ -n "${TGTOKEN:-}" ] && [ -n "${TGGRPID:-}" ]; then
				__old_note="${note:-}"
				old_short=$(printf '%s' "$local_before" | cut -c1-7)
				new_short=$(printf '%s' "$local_after" | cut -c1-7)
				note="Self-update applied on ${hostname} (branch ${_BRANCH}): ${old_short} -> ${new_short}"
				send_message_to_telegram || true
				note="${__old_note}"
			fi
			echo "Running the new version..."
			exec "$_SCRIPT" "${ARGS}"
			exit 0
		fi
	)
	echo "Already the latest version."
}

########################################################################################################
# The script starts here - Functions first
########################################################################################################

# Lets make sure we have some tools we need.  If not then the script will try to install dnsutils, if it 
# fails then exit.
# Handle CLI to enable self-update and exit
RAW_ARGS=("$@")

# Detect REBOOT to skip self-update on early boot
is_reboot_run=0
for _a in "${RAW_ARGS[@]}"; do
  case "$_a" in
    --reboot|REBOOT) is_reboot_run=1; break;;
  esac
done

# Enable self-update by editing /usr/local/etc/log-my-ip.ini
enable_self_update_ini()
{
	local ini="/usr/local/etc/log-my-ip.ini"
	# Require root to write the INI
	if [ "$(id -u)" != "0" ]; then
		echo -e "${_RED}Must be root to modify ${ini}${_RESTORE}"
		return 1
	fi
	# Create file if missing with minimal content
	if [ ! -f "$ini" ]; then
		mkdir -p /usr/local/etc
		{
			echo "# Auto-generated by log-my-ip.sh --enable-self-update"
			echo "USE_SELFUPATE=YES"
			echo "GIT_BRANCH=\"main\""
		} > "$ini"
	else
		# Update or append USE_SELFUPATE
		if grep -q '^USE_SELFUPATE=' "$ini"; then
			sed -i 's/^USE_SELFUPATE=.*/USE_SELFUPATE=YES/' "$ini"
		else
			echo "USE_SELFUPATE=YES" >> "$ini"
		fi
		# Update or append GIT_BRANCH
		if grep -q '^GIT_BRANCH=' "$ini"; then
			sed -i 's/^GIT_BRANCH=.*/GIT_BRANCH="main"/' "$ini"
		else
			echo 'GIT_BRANCH="main"' >> "$ini"
		fi
	fi
	echo -e "${_GREEN}Enabled self-update in ${ini}${_RESTORE}"
}

# Test for dnsutils - we need the dig command
check_for_deps()
{
	which dig &> /dev/null
	_HAVE_DIG=$?
	which lsb_release &> /dev/null
	_HAVE_LSB=$?
	which curl &> /dev/null
	_HAVE_CURL=$?

	if [ ${_HAVE_DIG} = 1 ] || [ ${_HAVE_LSB} = 1 ] || [ ${_HAVE_CURL} = 1 ]; then
		echo -e "${_RED}Oh SNAP! Looks like you're missing some dependencies.${_RESTORE}"
		if [ ${_HAVE_DIG} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}dig${_RESTORE} command. Please install ${_GREEN}dnsutils${_RESTORE} on DEB systems,"
			echo -e "and ${_GREEN}bind-utils${_RESTORE} on RPM systems."
			echo
		fi
		if [ ${_HAVE_LSB} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}lsb_release${_RESTORE} command. Please install ${_GREEN}redhat-lsb-core${_RESTORE} in CentOS and RHEL."
			echo
		fi
		if [ ${_HAVE_CURL} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}curl${_RESTORE} command. Please install ${_GREEN}curl${_RESTORE}."
			echo
		fi
		exit 1
	fi
}

# Resolve external/public IPv4 address using multiple strategies (DNS + HTTPS fallbacks)
get_external_ip()
{
	local cand=""
	# Try DNS methods first, if dig is available
	if command -v dig >/dev/null 2>&1; then
		cand="$(dig +short -4 TXT o-o.myaddr.l.google.com @ns1.google.com 2>/dev/null | tr -d '"' | head -n1)"
		if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
			cand="$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null | head -n1)"
		fi
	fi

	# If DNS didn't work, try HTTPS-based services with curl
	if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		for url in \
			https://api.ipify.org \
			https://ifconfig.me/ip \
			https://icanhazip.com \
			https://checkip.amazonaws.com \
			https://ipinfo.io/ip
		do
			cand="$(curl -4 -fsS --max-time 3 --connect-timeout 2 "$url" 2>/dev/null | tr -d '\n\r\t ' | head -c 64)"
			if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
				break
			fi
		done
	fi

	if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		extip="$cand"
	else
		extip="Unknown"
	fi
}

send_message_to_telegram()
{
    tmpfile=$(mktemp /tmp/telebot.XXXXXXX)
    cat > $tmpfile <<EOF
{"chat_id":"$TGGRPID", "parse_mode":"markdown", "text":"*System Update*: $note\n*Date*: ${mydate}\n*Hostname*: $hostname\n*Internal IP*: $intip\n*External IP*: $extip"}
EOF
    curl -k --header 'Content-Type: application/json' \
        --data-binary @${tmpfile} \
        --request POST ${TGURL}
    rm -f $tmpfile
}

# This function will send our reboot message to a server where you have a script running to receive it.
send_message_to_server()
{
	PING=1
	while [ ${PING} -gt 0 ]
	do
		ping -c 5 ${_MYSERVER} &> /dev/null
		PING=$?
	done
	wget ${WGETOPTS} ${GCURL} --post-data="hostname=${hostname}&intip=${intip}&extip=${extip}&mydate=${mydate}&note=${note}"
	if [ "${note}" = "REBOOT" ];then
		send_message
	fi
}

self_update() {
    [ "$UPDATE_GUARD" ] && return
    export UPDATE_GUARD=YES
    command -v git >/dev/null 2>&1 || return
    if ! getent hosts github.com >/dev/null 2>&1; then
        return
    fi

	_SCRIPT=$(readlink -f "$0")
	_SCRIPTPATH=$(dirname "$_SCRIPT")
	_SCRIPTNAME="$0"

	(
		cd "$_SCRIPTPATH" || exit 0
		command -v git >/dev/null 2>&1 || exit 0
		git fetch --all --quiet || exit 0
		local _BRANCH
		_BRANCH=${GIT_BRANCH:-main}
		git show-ref --verify --quiet "refs/remotes/origin/${_BRANCH}" || exit 0
		local local_before remote_target local_after
		local_before=$(git rev-parse --verify HEAD 2>/dev/null) || exit 0
		remote_target=$(git rev-parse --verify "origin/${_BRANCH}" 2>/dev/null) || exit 0
		if [ "$local_before" != "$remote_target" ]; then
			echo "Found a new version of me, updating myself..."
			git checkout -q "${_BRANCH}" || true
			git pull --force -q || true
			local_after=$(git rev-parse --verify HEAD 2>/dev/null) || local_after="unknown"
			# Optionally send a Telegram notice about the update
			if [ -n "${TGTOKEN:-}" ] && [ -n "${TGGRPID:-}" ]; then
				__old_note="${note:-}"
				old_short=$(printf '%s' "$local_before" | cut -c1-7)
				new_short=$(printf '%s' "$local_after" | cut -c1-7)
				note="Self-update applied on ${hostname} (branch ${_BRANCH}): ${old_short} -> ${new_short}"
				send_message_to_telegram || true
				note="${__old_note}"
			fi
			echo "Running the new version..."
			exec "$_SCRIPT" "${ARGS}"
			exit 0
		fi
	)
	echo "Already the latest version."
}

########################################################################################################
# The script starts here - Functions first
########################################################################################################

# Lets make sure we have some tools we need.  If not then the script will try to install dnsutils, if it 
# fails then exit.
# Handle CLI to enable self-update and exit
RAW_ARGS=("$@")

# Detect REBOOT to skip self-update on early boot
is_reboot_run=0
for _a in "${RAW_ARGS[@]}"; do
  case "$_a" in
    --reboot|REBOOT) is_reboot_run=1; break;;
  esac
done

# Enable self-update by editing /usr/local/etc/log-my-ip.ini
enable_self_update_ini()
{
	local ini="/usr/local/etc/log-my-ip.ini"
	# Require root to write the INI
	if [ "$(id -u)" != "0" ]; then
		echo -e "${_RED}Must be root to modify ${ini}${_RESTORE}"
		return 1
	fi
	# Create file if missing with minimal content
	if [ ! -f "$ini" ]; then
		mkdir -p /usr/local/etc
		{
			echo "# Auto-generated by log-my-ip.sh --enable-self-update"
			echo "USE_SELFUPATE=YES"
			echo "GIT_BRANCH=\"main\""
		} > "$ini"
	else
		# Update or append USE_SELFUPATE
		if grep -q '^USE_SELFUPATE=' "$ini"; then
			sed -i 's/^USE_SELFUPATE=.*/USE_SELFUPATE=YES/' "$ini"
		else
			echo "USE_SELFUPATE=YES" >> "$ini"
		fi
		# Update or append GIT_BRANCH
		if grep -q '^GIT_BRANCH=' "$ini"; then
			sed -i 's/^GIT_BRANCH=.*/GIT_BRANCH="main"/' "$ini"
		else
			echo 'GIT_BRANCH="main"' >> "$ini"
		fi
	fi
	echo -e "${_GREEN}Enabled self-update in ${ini}${_RESTORE}"
}

# Test for dnsutils - we need the dig command
check_for_deps()
{
	which dig &> /dev/null
	_HAVE_DIG=$?
	which lsb_release &> /dev/null
	_HAVE_LSB=$?
	which curl &> /dev/null
	_HAVE_CURL=$?

	if [ ${_HAVE_DIG} = 1 ] || [ ${_HAVE_LSB} = 1 ] || [ ${_HAVE_CURL} = 1 ]; then
		echo -e "${_RED}Oh SNAP! Looks like you're missing some dependencies.${_RESTORE}"
		if [ ${_HAVE_DIG} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}dig${_RESTORE} command. Please install ${_GREEN}dnsutils${_RESTORE} on DEB systems,"
			echo -e "and ${_GREEN}bind-utils${_RESTORE} on RPM systems."
			echo
		fi
		if [ ${_HAVE_LSB} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}lsb_release${_RESTORE} command. Please install ${_GREEN}redhat-lsb-core${_RESTORE} in CentOS and RHEL."
			echo
		fi
		if [ ${_HAVE_CURL} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}curl${_RESTORE} command. Please install ${_GREEN}curl${_RESTORE}."
			echo
		fi
		exit 1
	fi
}

# Resolve external/public IPv4 address using multiple strategies (DNS + HTTPS fallbacks)
get_external_ip()
{
	local cand=""
	# Try DNS methods first, if dig is available
	if command -v dig >/dev/null 2>&1; then
		cand="$(dig +short -4 TXT o-o.myaddr.l.google.com @ns1.google.com 2>/dev/null | tr -d '"' | head -n1)"
		if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
			cand="$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null | head -n1)"
		fi
	fi

	# If DNS didn't work, try HTTPS-based services with curl
	if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		for url in \
			https://api.ipify.org \
			https://ifconfig.me/ip \
			https://icanhazip.com \
			https://checkip.amazonaws.com \
			https://ipinfo.io/ip
		do
			cand="$(curl -4 -fsS --max-time 3 --connect-timeout 2 "$url" 2>/dev/null | tr -d '\n\r\t ' | head -c 64)"
			if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
				break
			fi
		done
	fi

	if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		extip="$cand"
	else
		extip="Unknown"
	fi
}

send_message_to_telegram()
{
    tmpfile=$(mktemp /tmp/telebot.XXXXXXX)
    cat > $tmpfile <<EOF
{"chat_id":"$TGGRPID", "parse_mode":"markdown", "text":"*System Update*: $note\n*Date*: ${mydate}\n*Hostname*: $hostname\n*Internal IP*: $intip\n*External IP*: $extip"}
EOF
    curl -k --header 'Content-Type: application/json' \
        --data-binary @${tmpfile} \
        --request POST ${TGURL}
    rm -f $tmpfile
}

# This function will send our reboot message to a server where you have a script running to receive it.
send_message_to_server()
{
	PING=1
	while [ ${PING} -gt 0 ]
	do
		ping -c 5 ${_MYSERVER} &> /dev/null
		PING=$?
	done
	wget ${WGETOPTS} ${GCURL} --post-data="hostname=${hostname}&intip=${intip}&extip=${extip}&mydate=${mydate}&note=${note}"
	if [ "${note}" = "REBOOT" ];then
		send_message
	fi
}

self_update() {
    [ "$UPDATE_GUARD" ] && return
    export UPDATE_GUARD=YES
    command -v git >/dev/null 2>&1 || return
    if ! getent hosts github.com >/dev/null 2>&1; then
        return
    fi

	_SCRIPT=$(readlink -f "$0")
	_SCRIPTPATH=$(dirname "$_SCRIPT")
	_SCRIPTNAME="$0"

	(
		cd "$_SCRIPTPATH" || exit 0
		command -v git >/dev/null 2>&1 || exit 0
		git fetch --all --quiet || exit 0
		local _BRANCH
		_BRANCH=${GIT_BRANCH:-main}
		git show-ref --verify --quiet "refs/remotes/origin/${_BRANCH}" || exit 0
		local local_before remote_target local_after
		local_before=$(git rev-parse --verify HEAD 2>/dev/null) || exit 0
		remote_target=$(git rev-parse --verify "origin/${_BRANCH}" 2>/dev/null) || exit 0
		if [ "$local_before" != "$remote_target" ]; then
			echo "Found a new version of me, updating myself..."
			git checkout -q "${_BRANCH}" || true
			git pull --force -q || true
			local_after=$(git rev-parse --verify HEAD 2>/dev/null) || local_after="unknown"
			# Optionally send a Telegram notice about the update
			if [ -n "${TGTOKEN:-}" ] && [ -n "${TGGRPID:-}" ]; then
				__old_note="${note:-}"
				old_short=$(printf '%s' "$local_before" | cut -c1-7)
				new_short=$(printf '%s' "$local_after" | cut -c1-7)
				note="Self-update applied on ${hostname} (branch ${_BRANCH}): ${old_short} -> ${new_short}"
				send_message_to_telegram || true
				note="${__old_note}"
			fi
			echo "Running the new version..."
			exec "$_SCRIPT" "${ARGS}"
			exit 0
		fi
	)
	echo "Already the latest version."
}

########################################################################################################
# The script starts here - Functions first
########################################################################################################

# Lets make sure we have some tools we need.  If not then the script will try to install dnsutils, if it 
# fails then exit.
# Handle CLI to enable self-update and exit
RAW_ARGS=("$@")

# Detect REBOOT to skip self-update on early boot
is_reboot_run=0
for _a in "${RAW_ARGS[@]}"; do
  case "$_a" in
    --reboot|REBOOT) is_reboot_run=1; break;;
  esac
done

# Enable self-update by editing /usr/local/etc/log-my-ip.ini
enable_self_update_ini()
{
	local ini="/usr/local/etc/log-my-ip.ini"
	# Require root to write the INI
	if [ "$(id -u)" != "0" ]; then
		echo -e "${_RED}Must be root to modify ${ini}${_RESTORE}"
		return 1
	fi
	# Create file if missing with minimal content
	if [ ! -f "$ini" ]; then
		mkdir -p /usr/local/etc
		{
			echo "# Auto-generated by log-my-ip.sh --enable-self-update"
			echo "USE_SELFUPATE=YES"
			echo "GIT_BRANCH=\"main\""
		} > "$ini"
	else
		# Update or append USE_SELFUPATE
		if grep -q '^USE_SELFUPATE=' "$ini"; then
			sed -i 's/^USE_SELFUPATE=.*/USE_SELFUPATE=YES/' "$ini"
		else
			echo "USE_SELFUPATE=YES" >> "$ini"
		fi
		# Update or append GIT_BRANCH
		if grep -q '^GIT_BRANCH=' "$ini"; then
			sed -i 's/^GIT_BRANCH=.*/GIT_BRANCH="main"/' "$ini"
		else
			echo 'GIT_BRANCH="main"' >> "$ini"
		fi
	fi
	echo -e "${_GREEN}Enabled self-update in ${ini}${_RESTORE}"
}

# Test for dnsutils - we need the dig command
check_for_deps()
{
	which dig &> /dev/null
	_HAVE_DIG=$?
	which lsb_release &> /dev/null
	_HAVE_LSB=$?
	which curl &> /dev/null
	_HAVE_CURL=$?

	if [ ${_HAVE_DIG} = 1 ] || [ ${_HAVE_LSB} = 1 ] || [ ${_HAVE_CURL} = 1 ]; then
		echo -e "${_RED}Oh SNAP! Looks like you're missing some dependencies.${_RESTORE}"
		if [ ${_HAVE_DIG} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}dig${_RESTORE} command. Please install ${_GREEN}dnsutils${_RESTORE} on DEB systems,"
			echo -e "and ${_GREEN}bind-utils${_RESTORE} on RPM systems."
			echo
		fi
		if [ ${_HAVE_LSB} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}lsb_release${_RESTORE} command. Please install ${_GREEN}redhat-lsb-core${_RESTORE} in CentOS and RHEL."
			echo
		fi
		if [ ${_HAVE_CURL} = 1 ]; then
			echo
			echo -e "Unable to find the ${_RED}curl${_RESTORE} command. Please install ${_GREEN}curl${_RESTORE}."
			echo
		fi
		exit 1
	fi
}

# Resolve external/public IPv4 address using multiple strategies (DNS + HTTPS fallbacks)
get_external_ip()
{
	local cand=""
	# Try DNS methods first, if dig is available
	if command -v dig >/dev/null 2>&1; then
		cand="$(dig +short -4 TXT o-o.myaddr.l.google.com @ns1.google.com 2>/dev/null | tr -d '"' | head -n1)"
		if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
			cand="$(dig +short myip.opendns.com @resolver1.opendns.com 2>/dev/null | head -n1)"
		fi
	fi

	# If DNS didn't work, try HTTPS-based services with curl
	if ! printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		for url in \
			https://api.ipify.org \
			https://ifconfig.me/ip \
			https://icanhazip.com \
			https://checkip.amazonaws.com \
			https://ipinfo.io/ip
		do
			cand="$(curl -4 -fsS --max-time 3 --connect-timeout 2 "$url" 2>/dev/null | tr -d '\n\r\t ' | head -c 64)"
			if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
				break
			fi
		done
	fi

	if printf '%s' "$cand" | grep -Eq '^[0-9]{1,3}(\.[0-9]{1,3}){3}$'; then
		extip="$cand"
	else
		extip="Unknown"
	fi
}

send_message_to_telegram()
{
    tmpfile=$(mktemp /tmp/telebot.XXXXXXX)
    cat > $tmpfile <<EOF
{"chat_id":"$TGGRPID", "parse_mode":"markdown", "text":"*System Update*: $note\n*Date*: ${mydate}\n*Hostname*: $hostname\n*Internal IP*: $intip\n*External IP*: $extip"}
EOF
    curl -k --header 'Content-Type: application/json' \
        --data-binary @${tmpfile} \
        --request POST ${TGURL}
    rm -f $tmpfile
}

# This function will send our reboot message to a server where you have a script running to receive it.
send_message_to_server()
{
	PING=1
	while [ ${PING} -gt 0 ]
	do
		ping -c 5 ${_MYSERVER} &> /dev/null
		PING=$?
	done
	wget ${WGETOPTS} ${GCURL} --post-data="hostname=${hostname}&intip=${intip}&extip=${extip}&mydate=${mydate}&note=${note}"
	if [ "${note}" = "REBOOT" ];then
		send_message
	fi
}

self_update() {
    [ "$UPDATE_GUARD" ] && return
    export UPDATE_GUARD=YES
    command -v git >/dev/null 2>&1 || return
    if ! getent hosts github.com >/dev/null 2>&1; then
        return
    fi

	_SCRIPT=$(readlink -f "$0")
	_SCRIPTPATH=$(dirname "$_SCRIPT")
	_SCRIPTNAME="$0"

	(
		cd "$_SCRIPTPATH" || exit 0
		command -v git >/dev/null 2>&1 || exit 0
		git fetch --all --quiet || exit 0
		local _BRANCH
		_BRANCH=${GIT_BRANCH:-main}
		git show-ref --verify --quiet "refs/remotes/origin/${_BRANCH}" || exit 0
		local local_before remote_target local_after
		local_before=$(git rev-parse --verify HEAD 2>/dev/null) || exit 0
		remote_target=$(git rev-parse --verify "origin/${_BRANCH}" 2>/dev/null) || exit 0
		if [ "$local_before" != "$remote_target" ]; then
			echo "Found a new version of me, updating myself..."
			git checkout -q "${_BRANCH}" || true
			git pull --force -q || true
			local_after=$(git rev-parse --verify HEAD 2>/dev/null) || local_after="unknown"
			# Optionally send a Telegram notice about the update
			if [ -n "${TGTOKEN:-}" ] && [ -n "${TGGRPID:-}" ]; then
				__old_note="${note:-}"
				old_short=$(printf '%s' "$local_before" | cut -c1-7)
				new_short=$(printf '%s' "$local_after" | cut -c1-7)
				note="Self-update applied on ${hostname} (branch ${_BRANCH}): ${old_short} -> ${new_short}"
				send_message_to_telegram || true
				note="${__old_note}"
			fi
			echo "Running the new version..."
			exec "$_SCRIPT" "${ARGS}"
			exit 0
		fi
	)
	echo "Already the latest version."
}